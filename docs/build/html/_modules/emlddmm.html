<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>emlddmm &mdash; GDM 0.0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> GDM
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coordinate_systems.html">Coordinate Systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../file_formats.html">File Formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../input_specification.html">Input specification via Transformation Graph Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../output_specification.html">Output Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../documentation.html">Function reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../todo.html">To Do</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">GDM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html">Module code</a> &raquo;</li>
      <li>emlddmm</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for emlddmm</h1><div class="highlight"><pre>
<span></span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch.nn.functional</span> <span class="kn">import</span> <span class="n">grid_sample</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span><span class="p">,</span><span class="n">split</span><span class="p">,</span><span class="n">splitext</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">makedirs</span>
<span class="kn">import</span> <span class="nn">nibabel</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="c1">#from skimage import measure, filters</span>
<span class="c1">#from mayavi import mlab</span>
<span class="c1"># import nrrd</span>
<span class="c1"># from scipy.spatial.distance import directed_hausdorff, dice</span>
<span class="c1"># from medpy.metric import binary</span>
<span class="kn">import</span> <span class="nn">tifffile</span> <span class="k">as</span> <span class="nn">tf</span> <span class="c1"># for 16 bit tiff</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">mode</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interpn</span>
<span class="kn">import</span> <span class="nn">PIL</span> <span class="c1"># only required for one format conversion function</span>
<span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">MAX_IMAGE_PIXELS</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># prevent decompression bomb error for large files</span>

<span class="c1"># display</span>
<div class="viewcode-block" id="extent_from_x"><a class="viewcode-back" href="../emlddmm.html#emlddmm.extent_from_x">[docs]</a><span class="k">def</span> <span class="nf">extent_from_x</span><span class="p">(</span><span class="n">xJ</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Given a set of pixel locations, returns an extent 4-tuple for use with imshow.</span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Note inputs are locations of pixels along each axis, i.e. row column not xy.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xJ : list of torch tensors</span>
<span class="sd">        Location of pixels along each axis</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    extent : tuple</span>
<span class="sd">        (xmin, xmax, ymin, ymax) tuple</span>
<span class="sd">    </span>
<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Draw a 2D image stored in J, with pixel locations of rows stored in xJ[0] and pixel locations</span>
<span class="sd">    of columns stored in xJ[1].</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; extent_from_x(xJ)</span>
<span class="sd">    &gt;&gt;&gt; fig,ax = plt.subplots()</span>
<span class="sd">    &gt;&gt;&gt; ax.imshow(J,extent=extentJ)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    <span class="n">extentJ</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
               <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
               <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
               <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">extentJ</span></div>
<div class="viewcode-block" id="draw"><a class="viewcode-back" href="../emlddmm.html#emlddmm.draw">[docs]</a><span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">n_slices</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">disp</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">slices_start_end</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>    
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Draw 3D imaging data.</span>
<span class="sd">    </span>
<span class="sd">    Images are shown by sampling slices along 3 orthogonal axes.</span>
<span class="sd">    Color or grayscale data can be shown.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : array like (torch tensor or numpy array)</span>
<span class="sd">        A 3D image with C channels should be size (C x nslice x nrow x ncol)</span>
<span class="sd">        Note grayscale images should have C=1, but still be a 4D array.</span>
<span class="sd">    xJ : list</span>
<span class="sd">        A list of 3 numpy arrays.  xJ[i] contains the positions of voxels</span>
<span class="sd">        along axis i.  Note these are assumed to be uniformly spaced. The default</span>
<span class="sd">        is voxels of size 1.0.</span>
<span class="sd">    fig : matplotlib figure</span>
<span class="sd">        A figure in which to draw pictures. Contents of the figure will be cleared.</span>
<span class="sd">        Default is None, which creates a new figure.</span>
<span class="sd">    n_slices : int</span>
<span class="sd">        An integer denoting how many slices to draw along each axis. Default 5.</span>
<span class="sd">    vmin</span>
<span class="sd">        A minimum value for windowing imaging data. Can also be a list of size C for</span>
<span class="sd">        windowing each channel separately. Defaults to None, which corresponds </span>
<span class="sd">        to tha 0.001 quantile on each channel.</span>
<span class="sd">    vmax</span>
<span class="sd">        A maximum value for windowing imaging data. Can also be a list of size C for</span>
<span class="sd">        windowing each channel separately. Defaults to None, which corresponds </span>
<span class="sd">        to tha 0.999 quantile on each channel.</span>
<span class="sd">    disp : bool</span>
<span class="sd">        Figure display toggle</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Other keywords will be passed on to the matplotlib imshow function. For example</span>
<span class="sd">        include cmap=&#39;gray&#39; for a gray colormap</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fig : matplotlib figure</span>
<span class="sd">        The matplotlib figure variable with data.</span>
<span class="sd">    axs : array of matplotlib axes</span>
<span class="sd">        An array of matplotlib subplot axes containing each image.</span>


<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    Here is an example::</span>

<span class="sd">       &gt;&gt;&gt; example test</span>
<span class="sd">   </span>
<span class="sd">    TODO</span>
<span class="sd">    ----</span>
<span class="sd">    Put interpolation=&#39;none&#39; in keywords</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">J</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xJ</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nJ</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nJ</span><span class="p">]</span> 
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>    
    <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="mf">0.001</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="mf">0.999</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>    
    <span class="c1"># I will normalize data with vmin, and display in 0,1</span>
    <span class="k">if</span> <span class="n">vmin</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">vmax</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># for rgb I&#39;ll scale it, otherwise I won&#39;t, so I can use colorbars</span>
        <span class="n">J</span> <span class="o">-=</span> <span class="n">vmin</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">J</span> <span class="o">/=</span> <span class="p">(</span><span class="n">vmax</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span>
        <span class="n">J</span><span class="p">[</span><span class="n">J</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J</span><span class="p">[</span><span class="n">J</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># I will only show the first 3 channels</span>
    <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    
    
    <span class="n">axs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">axsi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ax0</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>     
    <span class="k">if</span> <span class="n">slices_start_end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">slices_start_end</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">slices_start_end</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>     
        
    <span class="c1"># for origin upper (default), extent is x (small to big), then y reversed (big to small)</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_slices</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n_slices</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">toshow</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">toshow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="n">toshow</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axsi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axsi</span><span class="p">)</span>
    <span class="n">axsi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ax1</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>    
    <span class="k">if</span> <span class="n">slices_start_end</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">slices_start_end</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">slices_start_end</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>         
    <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_slices</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n_slices</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">n_slices</span><span class="p">)</span>      
        <span class="n">toshow</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,:,</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">toshow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="n">toshow</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axsi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axsi</span><span class="p">)</span>
    <span class="n">axsi</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># ax2</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>        
    <span class="k">if</span> <span class="n">slices_start_end</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">slices_start_end</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">slices_start_end</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">n_slices</span><span class="o">+</span><span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>     
    
    <span class="n">extent</span> <span class="o">=</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_slices</span><span class="p">):</span>        
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n_slices</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">n_slices</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">toshow</span> <span class="o">=</span> <span class="n">J</span><span class="p">[:,:,:,</span><span class="n">slices</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">toshow</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="n">toshow</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">axsi</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axsi</span><span class="p">)</span>
    
    <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">hspace</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">disp</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
    <span class="n">axs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">cbar</span> <span class="ow">and</span> <span class="n">disp</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span> <span class="k">if</span> <span class="s1">&#39;Image&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">h</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span><span class="n">ax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axs</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span><span class="n">axs</span></div>
    
    
<div class="viewcode-block" id="load_slices"><a class="viewcode-back" href="../emlddmm.html#emlddmm.load_slices">[docs]</a><span class="k">def</span> <span class="nf">load_slices</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">xJ</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Load a slice dataset.</span>
<span class="sd">    </span>
<span class="sd">    Load a slice dataset for histology registration. Slice datasets include pairs</span>
<span class="sd">    of images and json sidecar files, as well as one tsv file explaining the dataset.</span>
<span class="sd">    Note this code creates a 3D array by padding.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    target_name : string</span>
<span class="sd">        Name of a directory containing slice dataset.</span>
<span class="sd">    xJ : list, optional</span>
<span class="sd">        list of numpy arrays containing voxel positions along each axis.</span>
<span class="sd">        Images will be resampled by interpolation on this 3D grid.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xJ : list of numpy arrays</span>
<span class="sd">        Location of v</span>
<span class="sd">    J : numpy array</span>
<span class="sd">        Numpy array of size C x nslices x nrows x ncols where C is the number of channels</span>
<span class="sd">        e.g. C=3 for RGB.</span>
<span class="sd">    W0 : numpy array</span>
<span class="sd">        A nslices x nrows x ncols numpy array containing weights.  Weights are 0 where there </span>
<span class="sd">        was padding</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Document describing dataset format here: TODO XXXXX</span>
<span class="sd">    documented XXXX</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If the first image is not present in the image series.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(&#39;loading target images&#39;)</span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>
    <span class="c1"># current limitation</span>
    <span class="c1"># requires the word &#39;present&#39;</span>
    <span class="c1"># requires the first image to be present</span>
    <span class="c1"># expects data type to be in 0,1</span>
    <span class="c1"># assumes space directions are diagonal</span>
    <span class="c1"># todo: origin</span>
    <span class="c1"># we will need more control over the size, and we will need to maintain the origin of each slice</span>
    <span class="c1"># right now we have a heuristic for taking 99th percentile and expanding by 1%</span>
    
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># load the one tsv file</span>
    <span class="n">tsv_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="s1">&#39;samples.tsv&#39;</span> <span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">tsv_name</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">count</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">line</span> <span class="k">else</span> <span class="s1">&#39;    &#39;</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">headings</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">line</span><span class="p">)</span>                
                <span class="k">continue</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">line</span><span class="p">))</span>
    <span class="n">data_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data_</span>
    <span class="c1">#print(f&#39;dataset with shape {data.shape}&#39;)</span>
    
    <span class="c1"># now we will loop through the files and get the sizes </span>
    <span class="n">nJ_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">slice_status</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">J_</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_status</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;present&#39;</span><span class="p">:</span>            
            <span class="c1"># if i == 0:</span>
            <span class="c1">#     raise Exception(&#39;First image is not present&#39;)</span>
            <span class="c1"># J_.append(np.array([[[0.0,0.0,0.0]]]))</span>
            <span class="k">continue</span>
        <span class="n">namekey</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">searchstring</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span><span class="s1">&#39;*&#39;</span><span class="o">+</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">namekey</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39;*.json&#39;</span><span class="p">)</span>
        <span class="n">jsonfile</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">searchstring</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">jsonfile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">jsondata</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1">#nJ_[i] = np.array(jsondata[&#39;Sizes&#39;])</span>


        <span class="c1"># this should contain an image and a json    </span>

        <span class="n">image_name</span> <span class="o">=</span> <span class="n">jsondata</span><span class="p">[</span><span class="s1">&#39;DataFile&#39;</span><span class="p">]</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">image_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.tif&#39;</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span> <span class="n">image_name</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">target_name</span><span class="p">,</span><span class="n">image_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">J__</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="mf">255.0</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># no alpha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">J__</span> <span class="o">=</span> <span class="n">J__</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J__</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">J__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span><span class="o">%</span><span class="mi">20</span><span class="p">:</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">toshow</span> <span class="o">=</span> <span class="p">(</span><span class="n">J__</span><span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">J__</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">J__</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">J__</span><span class="p">))</span>
            <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">toshow</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;slice </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">image_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>    

        <span class="n">nJ_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J__</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">J_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J__</span><span class="p">)</span>
               


        <span class="c1"># the domain</span>
        <span class="c1"># if this is the first file we want to set up a 3D volume</span>
        <span class="k">if</span> <span class="s1">&#39;dJ&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="n">dJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jsondata</span><span class="p">[</span><span class="s1">&#39;SpaceDirections&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># note the order needs to be reversed</span>
        <span class="n">origin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jsondata</span><span class="p">[</span><span class="s1">&#39;SpaceOrigin&#39;</span><span class="p">])</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># z coordinates of slices</span>
    <span class="k">if</span> <span class="n">xJ</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#print(&#39;building grid&#39;)</span>
        <span class="c1"># build 3D coordinate grid</span>
        <span class="n">nJ0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">int</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span><span class="o">//</span><span class="n">dJ</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># length of z axis on the grid (there may be missing slices)</span>
        <span class="n">nJm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nJ_</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">nJm</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">nJ_</span><span class="p">,</span><span class="mf">0.95</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mf">1.01</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># this will look for outliers when there are a small number, really there just shouldn&#39;t be outliers</span>
        <span class="n">nJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">nJ0</span><span class="p">],</span><span class="n">nJm</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># get the minimum coordinate on each axis</span>
        <span class="n">xJmin</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="n">xJmin</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">xJ</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">d</span> <span class="o">+</span> <span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nJ</span><span class="p">,</span><span class="n">dJ</span><span class="p">,</span><span class="n">xJmin</span><span class="p">)]</span>
        <span class="c1">#print(xJ)</span>
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xJ</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>

    <span class="c1"># get the presence of a slice at z axis grid points. This is used for loading into a 3D volume. </span>
    <span class="c1"># slice_status = []</span>
    <span class="c1"># i = 0</span>
    <span class="c1"># j = 0</span>
    <span class="c1"># while i &lt; len(xJ[0]):</span>
    <span class="c1">#     if j == len(x0):</span>
    <span class="c1">#         slice_status = slice_status + [False]*(len(xJ[0])-i)</span>
    <span class="c1">#         break</span>
    <span class="c1">#     status = xJ[0][i] == x0[j]</span>
    <span class="c1">#     if status == False:</span>
    <span class="c1">#         i += 1</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         i += 1</span>
    <span class="c1">#         j += 1</span>
    <span class="c1">#     slice_status.append(status)</span>

    <span class="c1"># resample slices on 3D grid    </span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">XJ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span>
    <span class="n">W0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">XJ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1">#print(&#39;starting to interpolate slice dataset&#39;)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XJ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># if slice_status[j] == False:</span>
        <span class="k">if</span> <span class="n">slice_status</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;missing&#39;</span><span class="p">,</span><span class="s1">&#39;absent&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">,</span><span class="s1">&#39;False&#39;</span><span class="p">,</span><span class="s1">&#39;false&#39;</span><span class="p">]:</span>
            <span class="c1">#print(f&#39;slice {j} was missing&#39;)</span>
            <span class="k">continue</span>
        <span class="c1"># getting an index out of range issue in the line below (problem was &#39;missing&#39; versus &#39;absent&#39;)</span>
        <span class="c1">#print(dJ,J_[i].shape)</span>
        <span class="n">xJ_</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="mf">2.0</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
        <span class="c1"># note, padding mode border means weights will not be appropriate, change on jan 11, 2024</span>
        <span class="c1">#J[j] = np.transpose(interp(xJ_, J_[i].transpose(2,0,1), XJ[1:,0], interp2d=True, padding_mode=&quot;border&quot;), (1,2,0))</span>
        <span class="n">J</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">interp</span><span class="p">(</span><span class="n">xJ_</span><span class="p">,</span> <span class="n">J_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">interp2d</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="s2">&quot;zeros&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">W0_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">W0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1">#W0_[J[i,...,0] &gt; 0.0] = 1.0 # we check if the first channel is greater than 0</span>
        <span class="c1"># jan 11, 2024, I think there is a mistake above, I thnk it should be j</span>
        <span class="n">W0_</span><span class="p">[</span><span class="n">J</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="c1"># we check if the first channel is greater than 0</span>
        <span class="c1">#W0[i] = W0_</span>
        <span class="n">W0</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">W0_</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">J</span><span class="p">,(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>

    <span class="c1">#print(f&#39;J shape {J.shape}&#39;)</span>
    <span class="k">return</span> <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span></div>
    

            
<span class="c1"># resampling</span>
<div class="viewcode-block" id="sinc_resample_numpy"><a class="viewcode-back" href="../emlddmm.html#emlddmm.sinc_resample_numpy">[docs]</a><span class="k">def</span> <span class="nf">sinc_resample_numpy</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Perform sinc resampling of an image in numpy.</span>
<span class="sd">    </span>
<span class="sd">    This function does sinc resampling using numpy rfft</span>
<span class="sd">    torch does not let us control behavior of fft well enough</span>
<span class="sd">    This is intended to be used to resample velocity fields if necessary</span>
<span class="sd">    Only intending it to be used for upsampling.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : numpy array</span>
<span class="sd">        An image to be resampled. Can be an arbitrary number of dimensions.</span>
<span class="sd">    n : list of ints</span>
<span class="sd">        Desired dimension of output data.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Id : numpy array</span>
<span class="sd">        A resampled image of size n.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>        
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># output with correct normalization</span>
    <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">Id</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">Id</span></div>
    

<div class="viewcode-block" id="downsample_ax"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downsample_ax">[docs]</a><span class="k">def</span> <span class="nf">downsample_ax</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">ax</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Downsample imaging data along one of the first 5 axes.</span>
<span class="sd">    </span>
<span class="sd">    Imaging data is downsampled by averaging nearest pixels.</span>
<span class="sd">    Note that data will be lost from the end of images instead of padding.</span>
<span class="sd">    This function is generally called repeatedly on each axis.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : array like (numpy or torch)</span>
<span class="sd">        Image to be downsampled on one axis.</span>
<span class="sd">    down : int</span>
<span class="sd">        Downsampling factor.  2 means average pairs of nearest pixels </span>
<span class="sd">        into one new downsampled pixel</span>
<span class="sd">    ax : int</span>
<span class="sd">        Which axis to downsample along.</span>
<span class="sd">    W : np array</span>
<span class="sd">        A mask the same size as I, but without a &quot;channel&quot; dimension</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Id : array like</span>
<span class="sd">        The downsampled image.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If a mask (W) is included and ax == 0. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>        
    <span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span><span class="o">//</span><span class="n">down</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">I</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">device</span><span class="o">=</span><span class="n">W</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">W</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">dtype</span><span class="o">=</span><span class="n">W</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>            
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="c1"># ... should be enough but there really has to be a better way to do this        </span>
            <span class="c1"># note I could use &quot;take&quot;</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span><span class="o">/</span><span class="n">down</span>
        <span class="k">return</span> <span class="n">Id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if W is not none</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;W not supported with ax=0&#39;</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>        
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">ax</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
                <span class="n">Id</span> <span class="o">+=</span> <span class="n">I</span><span class="p">[:,:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span><span class="o">*</span><span class="n">W</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
                <span class="n">Wd</span> <span class="o">+=</span> <span class="n">W</span><span class="p">[:,:,:,:,</span><span class="n">d</span><span class="p">:</span><span class="n">down</span><span class="o">*</span><span class="n">nd</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span><span class="n">down</span><span class="p">]</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">Id</span> <span class="o">/</span> <span class="p">(</span><span class="n">Wd</span> <span class="o">+</span> <span class="n">Wd</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span>
        
        
        <span class="n">Wd</span> <span class="o">=</span> <span class="n">Wd</span> <span class="o">/</span> <span class="n">down</span>
        <span class="k">return</span> <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span></div>
        
<div class="viewcode-block" id="downsample"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downsample">[docs]</a><span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Downsample an image by an integer factor along each axis. Note extra data at </span>
<span class="sd">    the end will be truncated if necessary.</span>
<span class="sd">    </span>
<span class="sd">    If the first axis is for image channels, downsampling factor should be 1 on this.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : array (numpy or torch)</span>
<span class="sd">        Imaging data to downsample</span>
<span class="sd">    down : list of int</span>
<span class="sd">        List of downsampling factors for each axis.</span>
<span class="sd">    W : array (numpy or torch)</span>
<span class="sd">        A weight of the same size as I but without the &quot;channel&quot; dimension</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Id : array (numpy or torch as input)</span>
<span class="sd">        Downsampled imaging data.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">down</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">down</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">down</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="n">down</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">W</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Wd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Id</span> <span class="o">=</span> <span class="n">downsample_ax</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span> <span class="o">=</span> <span class="n">downsample_ax</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">Wd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span></div>


<div class="viewcode-block" id="downsample_image_domain"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downsample_image_domain">[docs]</a><span class="k">def</span> <span class="nf">downsample_image_domain</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Downsample an image as well as pixel locations</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xI : list of numpy arrays</span>
<span class="sd">        xI[i] is a numpy array storing the locations of each voxel</span>
<span class="sd">        along the i-th axis.</span>
<span class="sd">    I : array like</span>
<span class="sd">        Image to be downsampled</span>
<span class="sd">    down : list of ints</span>
<span class="sd">        Factor by which to downsample along each dimension</span>
<span class="sd">    W : array like</span>
<span class="sd">        Weights the same size as I, but without a &quot;channel&quot; dimension</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xId : list of numpy arrays</span>
<span class="sd">        New voxel locations in the same format as xI</span>
<span class="sd">    Id : numpy array</span>
<span class="sd">        Downsampled image.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If the length of down and xI are not equal.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xI</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Length of down and xI must be equal&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Id</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">)</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Id</span><span class="p">,</span><span class="n">Wd</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">down</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">W</span><span class="p">)</span>
    <span class="n">xId</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">down</span><span class="p">):</span>
        <span class="n">xId</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsample_ax</span><span class="p">(</span><span class="n">xI</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">d</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">W</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xId</span><span class="p">,</span><span class="n">Id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xId</span><span class="p">,</span><span class="n">Id</span><span class="p">,</span><span class="n">Wd</span></div>
    
    
<div class="viewcode-block" id="downmode"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downmode">[docs]</a><span class="k">def</span> <span class="nf">downmode</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">S_</span><span class="p">,</span><span class="n">down</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Downsamples a 3D image by taking the mode among rectangular neighborhoods.</span>
<span class="sd">    This is appropriate for label images, where averaging pixel values is not meaningful.</span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    2D images can be hanled by adding a singleton dimension</span>
<span class="sd">    no leading batch dimensions</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xI : list of 3 numpy arrays</span>
<span class="sd">        Locations of image pixels along each axis</span>
<span class="sd">    S_ : numpy array</span>
<span class="sd">        Numpy array storing imaging data.  Note there should not be</span>
<span class="sd">        a leading dimension for channels.</span>
<span class="sd">    down : list of 3 ints</span>
<span class="sd">        downsample by this factor along each axis.</span>
<span class="sd">                </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xd : list of 3 numpy arrays</span>
<span class="sd">        Locations of image pixels along each axis after downsampling.</span>
<span class="sd">    Sd : numpy array</span>
<span class="sd">        The downsampled image.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># crop it off the right side so its size is a multiple of down</span>
    <span class="n">nS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nSd</span> <span class="o">=</span> <span class="n">nS</span><span class="o">//</span><span class="n">down</span>
    <span class="n">nSu</span> <span class="o">=</span> <span class="n">nSd</span><span class="o">*</span><span class="n">down</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">S_</span><span class="p">)[:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="c1"># now reshape</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">S_</span><span class="p">,(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">S_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">S_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">down</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">down</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">S_</span> <span class="o">=</span> <span class="n">mode</span><span class="p">(</span><span class="n">S_</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># now same for xR</span>
    <span class="n">xI_</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xI_</span><span class="p">,</span><span class="n">S_</span></div>

<div class="viewcode-block" id="downmedian"><a class="viewcode-back" href="../emlddmm.html#emlddmm.downmedian">[docs]</a><span class="k">def</span> <span class="nf">downmedian</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">S_</span><span class="p">,</span><span class="n">down</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Downsamples a 3D image by taking the median among rectangular neighborhoods.</span>
<span class="sd">    This is often appropriate when image pixels has a small number of outliers, or when</span>
<span class="sd">    pixel values are assumed to be ordered, but don&#39;t otherwise belong to a vector space.</span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    2D images can be hanled by adding a singleton dimension</span>
<span class="sd">    no leading batch dimensions</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xI : list of 3 numpy arrays</span>
<span class="sd">        Locations of image pixels along each axis</span>
<span class="sd">    S_ : numpy array</span>
<span class="sd">        Numpy array storing imaging data.  Note there should not be</span>
<span class="sd">        a leading dimension for channels.</span>
<span class="sd">    down : list of 3 ints</span>
<span class="sd">        downsample by this factor along each axis.</span>
<span class="sd">                </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xd : list of 3 numpy arrays</span>
<span class="sd">        Locations of image pixels along each axis after downsampling.</span>
<span class="sd">    Sd : numpy array</span>
<span class="sd">        The downsampled image.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># crop it off the right side so its size is a multiple of down</span>
    <span class="n">nS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">S_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">nSd</span> <span class="o">=</span> <span class="n">nS</span><span class="o">//</span><span class="n">down</span>
    <span class="n">nSu</span> <span class="o">=</span> <span class="n">nSd</span><span class="o">*</span><span class="n">down</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">S_</span><span class="p">)[:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">0</span><span class="p">],:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="c1"># now reshape</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">S_</span><span class="p">,(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">S_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">S_</span> <span class="o">=</span> <span class="n">S_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">down</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">down</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nSd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">S_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">S_</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># now same for xR</span>
    <span class="n">xI_</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xI_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xI_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">][:</span><span class="n">nSu</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xI_</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nSd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">down</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xI_</span><span class="p">,</span><span class="n">S_</span></div>

<span class="c1"># build an interp function from grid sample</span>
<div class="viewcode-block" id="interp"><a class="viewcode-back" href="../emlddmm.html#emlddmm.interp">[docs]</a><span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">phii</span><span class="p">,</span> <span class="n">interp2d</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Interpolate an image with specified regular voxel locations at specified sample points.</span>
<span class="sd">    </span>
<span class="sd">    Interpolate the image I, with regular grid positions stored in x (1d arrays),</span>
<span class="sd">    at the positions stored in phii (3D or 4D arrays with first channel storing component)</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        x[i] is a numpy array storing the pixel locations of imaging data along the i-th axis.</span>
<span class="sd">        Note that this MUST be regularly spaced, only the first and last values are queried.</span>
<span class="sd">    I : array</span>
<span class="sd">        Numpy array or torch tensor storing 2D or 3D imaging data.  In the 3D case, I is a 4D array with </span>
<span class="sd">        channels along the first axis and spatial dimensions along the last 3. For 2D, I is a 3D array with</span>
<span class="sd">        spatial dimensions along the last 2.</span>
<span class="sd">    phii : array</span>
<span class="sd">        Numpy array or torch tensor storing positions of the sample points. phii is a 3D or 4D array</span>
<span class="sd">        with components along the first axis (e.g. x0,x1,x1) and spatial dimensions </span>
<span class="sd">        along the last axes.</span>
<span class="sd">    interp2d : bool, optional</span>
<span class="sd">        If True, interpolates a 2D image, otherwise 3D. Default is False (expects a 3D image).</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        keword arguments to be passed to the grid sample function. For example</span>
<span class="sd">        to specify interpolation type like nearest.  See pytorch grid_sample documentation.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : torch tensor</span>
<span class="sd">        Array storing an image with channels stored along the first axis. </span>
<span class="sd">        This is the input image resampled at the points stored in phii.</span>


<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># first we have to normalize phii to the range -1,1    </span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">phii</span><span class="p">)</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">phii</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">interp2d</span><span class="o">==</span><span class="kc">True</span> <span class="k">else</span> <span class="mi">3</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">phii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># note the above maps to 0,1</span>
    <span class="n">phii</span> <span class="o">*=</span> <span class="mf">2.0</span>
    <span class="c1"># to 0 2</span>
    <span class="n">phii</span> <span class="o">-=</span> <span class="mf">1.0</span>
    <span class="c1"># done</span>

    <span class="c1"># NOTE I should check that I can reproduce identity</span>
    <span class="c1"># note that phii must now store x,y,z along last axis</span>
    <span class="c1"># is this the right order?</span>
    <span class="c1"># I need to put batch (none) along first axis</span>
    <span class="c1"># what order do the other 3 need to be in?    </span>
    <span class="c1"># feb 2022</span>
    <span class="k">if</span> <span class="s1">&#39;padding_mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;padding_mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;border&#39;</span> <span class="c1"># note that default is zero</span>
    <span class="k">if</span> <span class="n">interp2d</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">phii</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">phii</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">grid_sample</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">phii</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># note align corners true means square voxels with points at their centers</span>
    <span class="c1"># post processing, get rid of batch dimension</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span></div>
    
<span class="c1"># now we need to create a flow</span>
<span class="c1"># timesteps will be along the first axis</span>
<div class="viewcode-block" id="v_to_phii"><a class="viewcode-back" href="../emlddmm.html#emlddmm.v_to_phii">[docs]</a><span class="k">def</span> <span class="nf">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Use Euler&#39;s method to construct a position field from a velocity field</span>
<span class="sd">    by integrating over time.</span>
<span class="sd">    </span>
<span class="sd">    This method uses interpolation and subtracts and adds identity for better</span>
<span class="sd">    behavior outside boundaries. This method is sometimes refered to as the</span>
<span class="sd">    method of characteristics.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xv : list of 1D tensors</span>
<span class="sd">        xv[i] is a tensor storing the location of the sample points along</span>
<span class="sd">        the i-th dimension of v</span>
<span class="sd">    v : 5D tensor</span>
<span class="sd">        5D tensor where first axis corresponds to time, second corresponds to </span>
<span class="sd">        component, and 3rd to 5th correspond to spatial dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------    </span>
<span class="sd">    phii : 4D tensor</span>
<span class="sd">        Inverse transformation is output with component on the first dimension</span>
<span class="sd">        and space on the last 3. Note that the whole timeseries is not output.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XV</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">XV</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span><span class="o">+</span><span class="n">Xs</span>
    <span class="k">return</span> <span class="n">phii</span></div>
        
    
<div class="viewcode-block" id="reshape_for_local"><a class="viewcode-back" href="../emlddmm.html#emlddmm.reshape_for_local">[docs]</a><span class="k">def</span> <span class="nf">reshape_for_local</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Reshapes an image into blocks for simple local contrast estimation.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : tensor</span>
<span class="sd">        3D image data where first index stores the channel information (i.e. 4D array)</span>
<span class="sd">    local_contrast : tensor</span>
<span class="sd">        1D tensor storing the block size on each dimension</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Jv : tensor</span>
<span class="sd">        Reshaped imaging data to be used for contrast estimation</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># get shapes and pad</span>
    <span class="n">Jshape</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">device</span><span class="o">=</span><span class="n">J</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">topad</span> <span class="o">=</span> <span class="n">Jshape</span><span class="o">%</span><span class="n">local_contrast</span>
    <span class="n">topad</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_contrast</span><span class="o">-</span><span class="n">topad</span><span class="p">)</span><span class="o">%</span><span class="n">local_contrast</span>    
    <span class="n">Jpad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">functional</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">J</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="n">topad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="n">topad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="n">topad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>   
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # let&#39;s do symmetric padding instead</span>
<span class="sd">    # note, we need cropping at the end to match this</span>
<span class="sd">    # if its even, they&#39;ll both be the same</span>
<span class="sd">    # if its odd, right will be one more</span>
<span class="sd">    leftpad = torch.floor(topad/2.0).int()</span>
<span class="sd">    rightpad = torch.ceil(topad/2.0).int()</span>
<span class="sd">    Jpad = torch.nn.functional.pad(J,(leftpad[2].item(),rightpad[2].item(),leftpad[1].item(),rightpad[1].item(),leftpad[0].item(),rightpad[0].item()))   </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># now reshape it</span>
    <span class="n">Jpad_</span> <span class="o">=</span> <span class="n">Jpad</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span> <span class="p">(</span><span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">//</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span>
                           <span class="n">Jpad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">//</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
    <span class="n">Jpad__</span> <span class="o">=</span> <span class="n">Jpad_</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Jpadv</span> <span class="o">=</span> <span class="n">Jpad__</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                           <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">Jpad__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">Jpadv</span></div>
                           
<div class="viewcode-block" id="reshape_from_local"><a class="viewcode-back" href="../emlddmm.html#emlddmm.reshape_from_local">[docs]</a><span class="k">def</span> <span class="nf">reshape_from_local</span><span class="p">(</span><span class="n">Jv</span><span class="p">,</span><span class="n">local_contrast</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    After changing contrast, transform back</span>
<span class="sd">    TODO: this did not get used</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>
    
<div class="viewcode-block" id="emlddmm"><a class="viewcode-back" href="../emlddmm.html#emlddmm.emlddmm">[docs]</a><span class="k">def</span> <span class="nf">emlddmm</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Run the EMLDDMM algorithm for deformable registration between two</span>
<span class="sd">    different imaging modalities with possible missing data in one of them</span>
<span class="sd">    </span>
<span class="sd">    Details of this algorithm can be found in</span>
<span class="sd">    </span>
<span class="sd">    * [1] Tward, Daniel, et al. &quot;Diffeomorphic registration with intensity transformation and missing data: Application to 3D digital pathology of Alzheimer&#39;s disease.&quot; Frontiers in neuroscience 14 (2020): 52.</span>
<span class="sd">    * [2] Tward, Daniel, et al. &quot;3d mapping of serial histology sections with anomalies using a novel robust deformable registration algorithm.&quot; Multimodal Brain Image Analysis and Mathematical Foundations of Computational Anatomy. Springer, Cham, 2019. 162-173.</span>
<span class="sd">    * [3] Tward, Daniel, et al. &quot;Solving the where problem in neuroanatomy: a generative framework with learned mappings to register multimodal, incomplete data into a reference brain.&quot; bioRxiv (2020).</span>
<span class="sd">    * [4] Tward DJ. An optical flow based left-invariant metric for natural gradient descent in affine image registration. Frontiers in Applied Mathematics and Statistics. 2021 Aug 24;7:718607.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Note all parameters are keyword arguments, but the first four are required.    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    </span>
<span class="sd">    xI : list of arrays</span>
<span class="sd">        xI[i] stores the location of voxels on the i-th axis of the atlas image I (REQUIRED)</span>
<span class="sd">    I : 4D array (numpy or torch)</span>
<span class="sd">        4D array storing atlas imaging data.  Channels (e.g. RGB are stored on the </span>
<span class="sd">        first axis, and the last three are spatial dimensions. (REQUIRED)</span>
<span class="sd">    xJ : list of arrays</span>
<span class="sd">        xJ[i] stores the location of voxels on the i-th axis of the target image J (REQUIRED)</span>
<span class="sd">    J : 4D array (numpy or torch)</span>
<span class="sd">        4D array storing target imaging data.  Channels (e.g. RGB are stored on the </span>
<span class="sd">        first axis, and the last three are spatial dimensions. (REQUIRED)</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of timesteps for integrating a velocity field to yeild a position field (default 5).</span>
<span class="sd">    eA : float</span>
<span class="sd">        Gradient descent step size for affine component (default 1e-5).  It is strongly suggested</span>
<span class="sd">        that you test this value and not rely on defaults. Note linear and translation components</span>
<span class="sd">        are combined following [4] so only one stepsize is required.</span>
<span class="sd">    ev : float</span>
<span class="sd">        Gradient descent step size for affine component (default 1e-5).  It is strongly suggested</span>
<span class="sd">        that you test this value and not rely on defaults.</span>
<span class="sd">    order : int</span>
<span class="sd">        Order of the polynomial used for contrast mapping. If using local contranst,</span>
<span class="sd">        only order 1 is supported.</span>
<span class="sd">    n_draw : int</span>
<span class="sd">        Draw a picture every n_draw iterations. 0 for do not draw.</span>
<span class="sd">    sigmaR : float</span>
<span class="sd">        Amount of regularization of the velocity field used for diffeomorphic transformation,</span>
<span class="sd">        of the form 1/sigmaR^2 * (integral over time of norm velocity squared ).</span>
<span class="sd">    n_iter : int</span>
<span class="sd">        How many iterations of optimization to run.</span>
<span class="sd">    n_e_step : int</span>
<span class="sd">        How many iterations of M step to run before another E step is ran in</span>
<span class="sd">        expectation maximization algorithm for detecting outliers.</span>
<span class="sd">    v_start : int</span>
<span class="sd">        What iteration to start optimizing velocity field.  One may want to compute an affine</span>
<span class="sd">        transformation before beginning to compute a deformation (for example).</span>
<span class="sd">    n_reduce_step : int</span>
<span class="sd">        Simple stepsize reducer for gradient descent optimization. Every this number of steps,</span>
<span class="sd">        we check if objective function is oscillating. If so we reduce the step size.</span>
<span class="sd">    v_expand_factor : float</span>
<span class="sd">        How much bigger than the atlas image should the domain of the velocity field be? This</span>
<span class="sd">        is helpful to avoid wraparound effects caused by discrete Fourier domain calculations.</span>
<span class="sd">        0.2 means 20% larger.</span>
<span class="sd">    v_res_factor : float</span>
<span class="sd">        How much lower resolution should the velocity field be sampled at than the atlas image.</span>
<span class="sd">        This is overrided if you specify dv.</span>
<span class="sd">    dv : None or float or list of 3 floats</span>
<span class="sd">        Explicitly state the resolution of the sampling grid for the velocity field.</span>
<span class="sd">    a : float</span>
<span class="sd">        Constant with units of length.  In velocity regularization, its square is multiplied against the Laplacian.</span>
<span class="sd">        Regularization is of the form 1/2/sigmaR^2 int |(id - a^2 Delta)^p v_t|^2_{L2} dt.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power of the Laplacian operator in regularization of the velocity field.  </span>
<span class="sd">        Regularization is of the form 1/2/sigmaR^2 int |(id - a^2 Delta)^p v_t|^2_{L2} dt.</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        Returns a dictionary of outputs storing computing transforms. if full_outputs==True, </span>
<span class="sd">        then more data is output including figures.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If the initial velocity does not have three components.</span>
<span class="sd">    Exception</span>
<span class="sd">        Local contrast transform requires either order = 1, or order &gt; 1 and 1D atlas.</span>
<span class="sd">    Exception</span>
<span class="sd">        If order &gt; 1. Local contrast transform not implemented yet except for linear.</span>
<span class="sd">    Exception</span>
<span class="sd">        Amode must be 0 (normal), 1 (rigid), or 2 (rigid+scale).</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># required arguments are</span>
    <span class="c1"># I - atlas image, size C x slice x row x column</span>
    <span class="c1"># xI - list of pixels locations in I, corresponding to each axis other than channels</span>
    <span class="c1"># J - target image, size C x slice x row x column</span>
    <span class="c1"># xJ - list of pixel locations in J</span>
    <span class="c1"># other parameters are specified in a dictionary with defaults listed below</span>
    <span class="c1"># if you provide an input for PARAMETER it will be used as an initial guess, </span>
    <span class="c1"># unless you specify update_PARAMETER=False, in which case it will be fixed</span>
    <span class="c1"># if you specify update_sigmaM=False it will use sum of square error, </span>
    <span class="c1"># otherwise it will use log determinant of diagonal covariance matrix</span>
    
    <span class="c1"># I should move them to torch and put them on the right device</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xI&#39;</span><span class="p">]</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;xJ&#39;</span><span class="p">]</span>
    
    <span class="c1">##########################################################################################################</span>
    <span class="c1"># everything else is optional, defaults are below</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;nt&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;eA&#39;</span><span class="p">:</span><span class="mf">1e5</span><span class="p">,</span>
                <span class="s1">&#39;ev&#39;</span><span class="p">:</span><span class="mf">2e3</span><span class="p">,</span>
                <span class="s1">&#39;order&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="c1"># order of polynomial</span>
                <span class="s1">&#39;n_draw&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;sigmaR&#39;</span><span class="p">:</span><span class="mf">1e6</span><span class="p">,</span>
                <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span><span class="mi">2000</span><span class="p">,</span>
                <span class="s1">&#39;n_e_step&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span>
                <span class="s1">&#39;v_start&#39;</span><span class="p">:</span><span class="mi">200</span><span class="p">,</span>
                <span class="s1">&#39;n_reduce_step&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span>
                <span class="s1">&#39;v_expand_factor&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span>
                <span class="s1">&#39;v_res_factor&#39;</span><span class="p">:</span><span class="mf">2.0</span><span class="p">,</span> <span class="c1"># gets ignored if dv is specified</span>
                <span class="s1">&#39;dv&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;a&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># note default below dv[0]*2.0</span>
                <span class="s1">&#39;p&#39;</span><span class="p">:</span><span class="mf">2.0</span><span class="p">,</span>    
                <span class="s1">&#39;aprefactor&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span> <span class="c1"># in terms of voxels in the downsampled atlas</span>
                <span class="s1">&#39;device&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># cuda:0 if available otherwise cpu</span>
                <span class="s1">&#39;dtype&#39;</span><span class="p">:</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span>
                <span class="s1">&#39;downI&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                <span class="s1">&#39;downJ&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>      
                <span class="s1">&#39;W0&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;priors&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_priors&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;full_outputs&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;muB&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_muB&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;muA&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_muA&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;sigmaA&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_sigmaA&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;sigmaB&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_sigmaB&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;sigmaM&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;update_sigmaM&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;Amode&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># 0 for standard, 1 for rigid, 2 for rigid+scale</span>
                <span class="s1">&#39;v&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;A2d&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>     
                <span class="s1">&#39;eA2d&#39;</span><span class="p">:</span><span class="mf">1e-3</span><span class="p">,</span> <span class="c1"># removed eL and eT using metric, need to double check 2d case works well</span>
                <span class="s1">&#39;slice_matching&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># if true include rigid motions and contrast on each slice</span>
                <span class="s1">&#39;slice_matching_start&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span>
                <span class="s1">&#39;slice_matching_isotropic&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># if true 3D affine is isotropic scale</span>
                <span class="s1">&#39;slice_matching_initialize&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># if True, AND no A2d specified, we will run atlas free as an initializer</span>
                <span class="s1">&#39;local_contrast&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># simple local contrast estimation mode, should be a list of ints</span>
                <span class="s1">&#39;reduce_factor&#39;</span><span class="p">:</span><span class="mf">0.9</span><span class="p">,</span>
                <span class="s1">&#39;auto_stepsize_v&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># 0 for no auto stepsize, or a number n for updating every n iterations</span>
                <span class="s1">&#39;up_vector&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span> <span class="c1"># the up vector in the atlas, which should remain up (pointing in the -y direction) in the target</span>
                <span class="s1">&#39;slice_deformation&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span> <span class="c1"># if slice_matching is also true, we will add 2d deformation. mostly use same parameters</span>
                <span class="s1">&#39;ev2d&#39;</span><span class="p">:</span><span class="mf">1e-6</span><span class="p">,</span>                                
                <span class="s1">&#39;v2d&#39;</span><span class="p">:</span><span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;slice_deformation_start&#39;</span><span class="p">:</span><span class="mi">250</span><span class="p">,</span>                
               <span class="p">}</span>
    <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="n">defaults</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;device&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">device</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cuda:0&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span>
    
    <span class="c1"># move the above to the right device</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
    
    
    <span class="c1">##########################################################################################################</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nt&#39;</span><span class="p">]</span>
    <span class="n">eA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;eA&#39;</span><span class="p">]</span>
    <span class="n">ev</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ev&#39;</span><span class="p">]</span>
    <span class="n">eA2d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;eA2d&#39;</span><span class="p">]</span>
    
    <span class="n">reduce_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;reduce_factor&#39;</span><span class="p">]</span>
    <span class="n">auto_stepsize_v</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;auto_stepsize_v&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">auto_stepsize_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">auto_stepsize_v</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> 
    
    <span class="n">sigmaR</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaR&#39;</span><span class="p">]</span>
    <span class="n">n_iter</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_iter&#39;</span><span class="p">]</span>
    <span class="n">v_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v_start&#39;</span><span class="p">]</span>
    <span class="n">n_draw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_draw&#39;</span><span class="p">]</span>
    <span class="n">n_e_step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_e_step&#39;</span><span class="p">]</span>
    <span class="n">n_reduce_step</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;n_reduce_step&#39;</span><span class="p">]</span>
    
    <span class="n">v_expand_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v_expand_factor&#39;</span><span class="p">]</span>
    <span class="n">v_res_factor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v_res_factor&#39;</span><span class="p">]</span>
    <span class="n">dv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dv&#39;</span><span class="p">]</span>
    
    <span class="n">a</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
    <span class="n">aprefactor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;aprefactor&#39;</span><span class="p">]</span>
        
    
    <span class="n">downI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span>
    <span class="n">downJ</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">]</span>
    <span class="n">W0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;W0&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">W0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># this has only one channel and should not have extra dimension in front</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">W0</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W0</span><span class="p">)</span> 
    <span class="n">priors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;priors&#39;</span><span class="p">]</span>
    <span class="n">update_priors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_priors&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">priors</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update_priors</span><span class="p">:</span>        
        <span class="n">priors</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]</span>
    <span class="n">full_outputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;full_outputs&#39;</span><span class="p">]</span>
    <span class="n">muA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;muA&#39;</span><span class="p">]</span>
    <span class="n">update_muA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_muA&#39;</span><span class="p">]</span>
    <span class="n">muB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;muB&#39;</span><span class="p">]</span>
    <span class="n">update_muB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_muB&#39;</span><span class="p">]</span>
    <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaA&#39;</span><span class="p">]</span>
    <span class="n">update_sigmaA</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_sigmaA&#39;</span><span class="p">]</span>
    <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaB&#39;</span><span class="p">]</span>
    <span class="n">update_sigmaB</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_sigmaB&#39;</span><span class="p">]</span>
    <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sigmaM&#39;</span><span class="p">]</span>
    <span class="n">update_sigmaM</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;update_sigmaM&#39;</span><span class="p">]</span>
    
    
    <span class="n">A</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">Amode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;Amode&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
    
    <span class="c1"># slice matching</span>
    <span class="n">slice_matching</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">slice_matching</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slice_matching</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
    <span class="n">slice_matching_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching_start&#39;</span><span class="p">]</span>
    <span class="n">slice_matching_isotropic</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching_isotropic&#39;</span><span class="p">]</span>
    
    <span class="c1"># slice deformation</span>
    <span class="n">slice_deformation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_deformation&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">slice_deformation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slice_deformation</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">slice_deformation</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;slice deformation is only available if slice matching is True&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_deformation</span><span class="p">:</span>
        <span class="n">v2d</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v2d&#39;</span><span class="p">]</span>
    <span class="n">slice_deformation_start</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_deformation_start&#39;</span><span class="p">]</span>
    
    
    <span class="c1"># local contrast, a list of ints, if empty don&#39;t do it</span>
    <span class="n">local_contrast</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;local_contrast&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">local_contrast</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">local_contrast</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">local_contrast</span><span class="p">:</span>
        <span class="n">local_contrast</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="c1"># up vector</span>
    <span class="n">up_vector</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;up_vector&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">up_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">up_vector</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">up_vector</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">up_vector</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;problem with up vector&#39;</span><span class="p">)</span>
    
    
    
    
    <span class="c1">##########################################################################################################    </span>
    <span class="c1"># domain</span>
    <span class="n">dI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">dJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>    
    <span class="n">nI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">nJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    <span class="c1"># set up a domain for xv    </span>
    <span class="c1"># I&#39;ll put it a bit bigger than xi</span>
    <span class="k">if</span> <span class="n">dv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">dI</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v_res_factor</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="c1"># we want this to be independent of the I downsampling, </span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span><span class="nb">float</span><span class="p">):</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">dv</span><span class="p">,</span><span class="n">dv</span><span class="p">,</span><span class="n">dv</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">dv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dv must be a scalar or a 3 element list, but was </span><span class="si">{</span><span class="n">dv</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just try it</span>
            <span class="n">dv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;dv must be a scalar or a 3 element list, but was </span><span class="si">{</span><span class="n">dv</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
                                                    
        
    <span class="c1"># feb 4, 2022, I want it to be isotropic though</span>
    <span class="c1">#print(f&#39;dv {dv}&#39;)</span>
    <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">2.0</span> <span class="c1"># so this is also independent of the I downsampling amount</span>
    <span class="c1">#print(f&#39;a scale is {a}&#39;)</span>
    <span class="n">x0v</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">v_expand_factor</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">x1v</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">v_expand_factor</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x0v</span><span class="p">,</span><span class="n">x1v</span><span class="p">,</span><span class="n">dv</span><span class="p">)]</span>
    <span class="n">nv</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="c1">#print(f&#39;velocity size is {nv}&#39;)</span>
    
    
    <span class="c1"># downample    </span>
    <span class="n">xI</span><span class="p">,</span><span class="n">I</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">downI</span><span class="p">)</span>
    <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">downJ</span><span class="p">,</span><span class="n">W</span><span class="o">=</span><span class="n">W0</span><span class="p">)</span>
    <span class="n">dI</span> <span class="o">*=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">downI</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="n">dJ</span> <span class="o">*=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">downJ</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>
    <span class="c1"># I think the above two lines are wrong, let&#39;s just repeat</span>
    <span class="n">dI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">dJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>    
    <span class="n">nI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">nJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    
    <span class="n">vminI</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.001</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
    <span class="n">vmaxI</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.999</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">I</span><span class="p">]</span>
    <span class="n">vminJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.001</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">]</span>
    <span class="n">vmaxJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J_</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="mf">0.999</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">]</span>
    
        
    <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    
    
    <span class="c1"># build an affine metric for 3D affine</span>
    <span class="c1"># this one is based on pullback metric from action on voxel locations (not image)</span>
    <span class="c1"># build a basis in lexicographic order and push forward using the voxel locations</span>
    <span class="n">XI_</span> <span class="o">=</span> <span class="n">XI</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>    
    <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="p">)</span>
    <span class="c1"># it would be nice to define scaling so that the norm of a perturbation had units of microns</span>
    <span class="c1"># e.g. root mean square displacement</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
        <span class="n">EiX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
            <span class="n">EjX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># matrix multiplication            </span>
            <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EiX</span><span class="o">*</span><span class="n">EjX</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dI</span><span class="p">)</span> <span class="c1"># because gradient has a factor of N in it, I think its a good idea to do sum</span>
    <span class="c1"># note, on july 21 I add factor of voxel size, so it can cancel with factor in cost function</span>

    <span class="c1"># feb 2, 2022, use double precision.  TODO: implement this as a solve when it is applied instead of inverse</span>
    <span class="n">gi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">double</span><span class="p">())</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    

    <span class="c1"># TODO affine metric for 2D affine</span>
    <span class="c1"># I&#39;ll use a quick hack for now</span>
    <span class="c1"># this is again based on pullback metric for voxel locations</span>
    <span class="c1"># need to verify that this is correct given possibly moving coordinate</span>
    <span class="c1"># maybe better </span>
    <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">g2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
        <span class="n">EiX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,:])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
            <span class="n">EjX</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@XI_</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:,:])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">][:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">g2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">EiX</span><span class="o">*</span><span class="n">EjX</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dI</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># feb 2, 2022, use double precision.  TODO: implement this as a solve when it is applied instead of inverse</span>
    <span class="n">g2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">g2d</span><span class="o">.</span><span class="n">double</span><span class="p">())</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            
    <span class="c1"># build energy and smoothing operator for velocity</span>
    <span class="n">fv</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">/</span><span class="n">d</span><span class="o">/</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nv</span><span class="p">,</span><span class="n">dv</span><span class="p">)]</span>
    <span class="n">FV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">fv</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>

    <span class="n">LL</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> 
              <span class="p">(</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
            <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
            <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>   <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">LL</span>

    <span class="n">LLpre</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">aprefactor</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dI</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> 
             <span class="p">(</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
             <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  
             <span class="o">+</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">FV</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">dv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>   <span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Kpre</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">LLpre</span>
    <span class="n">KK</span> <span class="o">=</span> <span class="n">K</span><span class="o">*</span><span class="n">Kpre</span>

    <span class="c1"># build energy and smoothing operator for 2d velocity</span>
    <span class="k">if</span> <span class="n">slice_deformation</span><span class="p">:</span>
        <span class="n">x0v2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">v_expand_factor</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">x1v2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">v_expand_factor</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
        <span class="n">xv2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x0v2d</span><span class="p">,</span><span class="n">x1v2d</span><span class="p">,</span><span class="n">dv</span><span class="p">)]</span>
        <span class="n">nv2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xv2d</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">XV2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv2d</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    
    
    <span class="c1"># now initialize variables and optimizers    </span>
    <span class="n">vsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vsize</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># check the size</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">==</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">vsize</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)):</span>
            <span class="c1"># note as_tensor will not do a copy if it is the same dtype and device</span>
            <span class="c1"># torch.tensor will always copy</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> 
            <span class="n">v</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">vsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Initial velocity must have 3 components&#39;</span><span class="p">)</span>
            <span class="c1"># resample it</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">sinc_resample_numpy</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">vsize</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">v</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
            
    <span class="k">if</span> <span class="n">slice_deformation</span><span class="p">:</span>
        <span class="n">v2dsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">nt</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">nv2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">inv2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">v2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">v2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v2dsize</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check the size</span>
            <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v2d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">==</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v2dsize</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v2d</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
                    <span class="n">v2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v2d</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">v2d</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">v2d</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">v2dsize</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">raise</span> <span class="n">EXception</span><span class="p">(</span><span class="s1">&#39;Initial 2d velocity must have 2 components&#39;</span><span class="p">)</span>
                <span class="c1"># resample it</span>
                <span class="n">v2d</span> <span class="o">=</span> <span class="n">sinc_resample_numpy</span><span class="p">(</span><span class="n">v2d</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">vsize</span><span class="p">)</span>
                <span class="n">v2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">v2d</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">v2d</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
            
            
            
    <span class="c1"># TODO: what if A is a strong because it came from a json file?</span>
    <span class="c1"># should be okay, the json loader will convert it to lists of lists </span>
    <span class="c1"># and that will initialize correctly</span>
    <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># use tensor, not as_tensor, to make a copy</span>
        <span class="c1"># A = torch.tensor(A,device=device,dtype=dtype)</span>
        <span class="c1"># This is only to bypass the warning message. Gray, Sep. 2022</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">A</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>

        
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">A2d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">A2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">A2d</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
            
            
            <span class="c1"># TODO, here if  slice_matching_initialize is true</span>
            <span class="n">slice_matching_initialize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;slice_matching_initialize&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">slice_matching_initialize</span><span class="p">:</span>
                <span class="c1"># do the atlas free reconstruction to start at lowest resolution</span>
                <span class="c1"># TODO</span>
                <span class="k">pass</span>
                
            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use tensor not as tensor to make a copy</span>
            <span class="c1"># A2d = torch.tensor(A2d, device=device, dtype=dtype)</span>
            <span class="c1"># This is only to bypass the warning message. Gray, Sep. 2022</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
                <span class="n">A2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">A2d</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">A2d</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># if slice matching is on we want to add xy translation in A to A2d</span>
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A2di</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@vec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">WM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">*</span><span class="mf">0.8</span>
    <span class="n">WA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>
    <span class="n">WB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>

    <span class="k">if</span> <span class="n">muA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>         
        <span class="c1">#muA = torch.tensor([torch.max(J_[W0&gt;0]) for J_ in J],dtype=dtype,device=device)      </span>
        <span class="n">muA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span> <span class="p">(</span><span class="n">J_</span><span class="p">[</span><span class="n">W0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="mf">0.999</span> <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if we input some value, we&#39;ll just use that</span>
        <span class="n">muA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">muA</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>    
    <span class="k">if</span> <span class="n">muB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#muB = torch.tensor([torch.min(J_[W0&gt;0]) for J_ in J],dtype=dtype,device=device)  </span>
        <span class="n">muB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span> <span class="p">(</span><span class="n">J_</span><span class="p">[</span><span class="n">W0</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span> <span class="mf">0.001</span> <span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">J_</span> <span class="ow">in</span> <span class="n">J</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if we input a value we&#39;ll just use that</span>
        <span class="n">muB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">muB</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>        
    <span class="c1"># TODO update to covariance, for now just diagonal</span>
    <span class="n">DJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dJ</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmaM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mf">1.0</span><span class="c1">#*DJ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">sigmaM</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmaA</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mf">5.0</span><span class="c1">#*DJ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">sigmaA</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sigmaB</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">*</span><span class="mf">2.0</span><span class="c1">#*DJ</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">sigmaB</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_draw</span><span class="p">:</span> <span class="c1"># if n_draw is not 0, we create figures</span>
        <span class="n">figE</span><span class="p">,</span><span class="n">axE</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">figA</span><span class="p">,</span><span class="n">axA</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">axA</span> <span class="o">=</span> <span class="n">axA</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="n">figA2d</span><span class="p">,</span><span class="n">axA2d</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">axA2d</span> <span class="o">=</span> <span class="n">axA2d</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">figI</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figfI</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figErr</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figJ</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figV</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">figW</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>


    <span class="n">Esave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Lsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Tsave</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">T2dsave</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">L2dsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">maxvsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sigmaMsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sigmaAsave</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sigmaBsave</span> <span class="o">=</span> <span class="p">[]</span>

    
    <span class="c1">################################################################################</span>
    <span class="c1"># end of setup, start optimization loop</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_iter</span><span class="p">):</span>
        <span class="c1"># get the transforms        </span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="c1"># on the second iteration I was getting an error here </span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># 2D transforms</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>            
            <span class="n">XJ_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJ</span><span class="p">)</span>
            <span class="c1"># leave z component the same (x0) and transform others                   </span>
            <span class="n">XJ_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">XJ_</span> <span class="o">=</span> <span class="n">XJ</span>

        <span class="c1"># sample points for affine</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ_</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># for diffeomorphism</span>
        <span class="n">phiiAi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs</span>
        
        <span class="c1"># transform image</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phiiAi</span><span class="p">)</span>

        <span class="c1"># transform contrast</span>
        <span class="c1"># I&#39;d like to support two cases, order 1 and arbitrary dim</span>
        <span class="c1"># or order &gt; 1 and 1 dim</span>
        <span class="c1"># first step is to set up the basis functions</span>
        <span class="n">Nvoxels</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="c1"># why did I write 0, well its equal to 1 here        </span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span> <span class="c1"># an empty list means global contrast</span>
            <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nvoxels</span><span class="p">,</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
                    <span class="n">B_</span><span class="p">[:,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># this assumes atlas is only dim 1, okay for now</span>
            <span class="k">elif</span> <span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># in this case, I still need a column of ones</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nvoxels</span><span class="p">,</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="n">B_</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">AphiI</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># should be ok, skip contrast estimation</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Require either order = 1 or order&gt;1 and 1D atlas&#39;</span><span class="p">)</span>
            <span class="c1"># note B was size N voxels by N channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># simple approach to local contrast</span>
            <span class="c1"># we will pad and refactor</span>
            <span class="c1"># pad AphiI</span>
            <span class="c1"># permute</span>
            <span class="c1"># reshape</span>
            <span class="c1"># find out how much to pad</span>
            <span class="c1"># this weight variable will have zeros at the end</span>
            <span class="n">Wlocal</span> <span class="o">=</span> <span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span>           
            
            <span class="c1"># test</span>
            <span class="n">Jpadv</span> <span class="o">=</span> <span class="n">reshape_for_local</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">)</span>
            <span class="n">Wlocalpadv</span> <span class="o">=</span> <span class="n">reshape_for_local</span><span class="p">(</span><span class="n">Wlocal</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">)</span>
            <span class="n">AphiIpadv</span> <span class="o">=</span> <span class="n">reshape_for_local</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">local_contrast</span><span class="p">)</span>
            
            <span class="c1"># now basis function</span>
            <span class="k">if</span> <span class="n">order</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>                
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;local not implemented yet except for linear&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">AphiIpadv</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="n">AphiIpadv</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Require either order = 1 or order&gt;1 and 1D atlas&#39;</span><span class="p">)</span>
            
        

        <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_matching</span> <span class="ow">or</span> <span class="p">(</span><span class="n">slice_matching</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span><span class="o">!=</span><span class="nb">list</span> <span class="ow">and</span> <span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">local_contrast</span><span class="p">)</span><span class="o">==</span><span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">fAphiI</span> <span class="o">=</span> <span class="n">AphiI</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># global contrast mapping</span>
                    <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>                
                        <span class="c1"># multiply by weight</span>
                        <span class="n">B__</span> <span class="o">=</span> <span class="n">B_</span><span class="o">*</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                        <span class="c1"># feb 2, 2022 converted from inv to solve and used double</span>
                        <span class="c1"># august 2022 add id a small constnat times identity, but I&#39;ll set it to zero for now so no change</span>
                        <span class="n">small</span> <span class="o">=</span> <span class="mf">1e-2</span><span class="o">*</span><span class="mi">0</span>
                        <span class="c1"># september 2023, set to 1e-4, because I was getting nan</span>
                        <span class="n">small</span> <span class="o">=</span> <span class="mf">1e-4</span>
                        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">((</span><span class="n">B__</span><span class="o">.</span><span class="n">T</span><span class="nd">@B_</span><span class="p">)</span><span class="o">.</span><span class="n">double</span><span class="p">()</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">B__</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">*</span><span class="n">small</span><span class="p">,</span> 
                                                    <span class="p">(</span><span class="n">B__</span><span class="o">.</span><span class="n">T</span><span class="o">@</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">double</span><span class="p">()</span> <span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">fAphiI</span> <span class="o">=</span> <span class="p">((</span><span class="n">B_</span><span class="nd">@coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="c1"># there are unnecessary transposes here, probably slowing down, to fix later</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># local contrast estimation using refactoring</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="n">BB</span> <span class="o">=</span> <span class="n">B_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="n">B_</span><span class="o">*</span><span class="n">Wlocalpadv</span><span class="p">)</span>
                    <span class="n">BJ</span> <span class="o">=</span> <span class="n">B_</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">@</span><span class="p">(</span><span class="n">Jpadv</span><span class="o">*</span><span class="n">Wlocalpadv</span><span class="p">)</span>
                    <span class="n">small</span> <span class="o">=</span> <span class="mf">1e-2</span>
                    <span class="c1"># convert to double here</span>
                    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span> <span class="n">BB</span><span class="o">.</span><span class="n">double</span><span class="p">()</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">BB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">BB</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">*</span><span class="n">small</span><span class="p">,</span><span class="n">BJ</span><span class="o">.</span><span class="n">double</span><span class="p">())</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">fAphiIpadv</span> <span class="o">=</span> <span class="p">(</span><span class="n">B_</span><span class="nd">@coeffs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                                                 <span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> 
                                                 <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># reverse this permutation (1,3,5,2,4,6,0)</span>
                <span class="n">fAphiIpad_</span> <span class="o">=</span> <span class="n">fAphiIpadv</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>        
                <span class="n">fAphiIpad</span> <span class="o">=</span> <span class="n">fAphiIpad_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> 
                                              <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> 
                                              <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> 
                                              <span class="n">Jpadv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">local_contrast</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
                <span class="n">fAphiI</span> <span class="o">=</span> <span class="n">fAphiIpad</span><span class="p">[:,:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],:</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
                <span class="c1"># todo, symmetric cropping and padding</span>


        <span class="k">else</span><span class="p">:</span> <span class="c1"># with slice matching I need to solve these equation for every slice</span>
            <span class="c1"># so far it looks like it is exactly the same as the above</span>
            <span class="c1"># I need to update</span>
            <span class="c1"># TODO</span>
            <span class="c1"># recall B_ is size nvoxels by nchannels</span>
            <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">fAphiI</span> <span class="o">=</span> <span class="n">AphiI</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">B_</span> <span class="o">=</span> <span class="n">B_</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">B_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>




                <span class="c1"># now be is nslices x npixels x nchannels B</span>
                <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                    <span class="c1"># multiply by weight                </span>
                    <span class="n">B__</span> <span class="o">=</span> <span class="n">B_</span><span class="o">*</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">WM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>     
                    <span class="c1"># B__ is shape nslices x npixels x nchannelsB</span>
                    <span class="n">BB</span> <span class="o">=</span> <span class="n">B__</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="nd">@B_</span>
                    <span class="c1"># BB is shape nslices x nchannelsb x nchannels b</span>

                    <span class="n">J_</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>        
                    <span class="c1"># J_ is shape nslices x npixels x nchannelsJ</span>
                    <span class="c1"># B__.T is shape nslices x nchannelsB x npixels</span>
                    <span class="n">BJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">B__</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">@</span> <span class="n">J_</span>
                    <span class="c1"># BJ is shape nslices x nchannels B x nchannels J</span>
                    <span class="c1"># TODO: add identity to BB</span>
                    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">BB</span> <span class="o">+</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">BB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">device</span><span class="o">=</span><span class="n">BB</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">BB</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">((</span><span class="n">BB</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">BB</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-6</span><span class="p">)</span> <span class="o">@</span> <span class="n">BJ</span>
                    <span class="c1"># coeffs is shape nslices x nchannelsB x nchannelsJ</span>


                <span class="n">fAphiI</span> <span class="o">=</span> <span class="p">(</span><span class="n">B_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span><span class="nd">@coeffs</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        

        
        <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="n">fAphiI</span> <span class="o">-</span> <span class="n">J</span><span class="p">)</span>
        <span class="n">err2</span> <span class="o">=</span> <span class="p">(</span><span class="n">err</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">))</span>
        <span class="c1"># most of my updates are below (at the very end), but I&#39;ll update this here because it is in my cost function</span>
        <span class="c1"># note that in my derivation, the sigmaM should have this factor of DJ</span>
        <span class="n">sseM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span> <span class="n">err2</span><span class="p">,(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">update_sigmaM</span><span class="p">:</span>
            <span class="n">sigmaM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sseM</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">))</span><span class="c1">#*DJ</span>
        
        <span class="n">sigmaMsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmaM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">JmmuA2</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">muA</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">JmmuB2</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">muB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">n_e_step</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>                                
                <span class="k">if</span> <span class="n">update_priors</span><span class="p">:</span>
                    <span class="n">priors</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WA</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WB</span><span class="o">*</span><span class="n">W0</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">]</span>                         
                
                <span class="n">WM</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigmaM</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>  <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaM</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="p">)</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">WA</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigmaA</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>  <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuA2</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaA</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="p">)</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">WB</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">sigmaB</span><span class="p">)</span> <span class="o">*</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span>  <span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuB2</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaB</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>  <span class="p">)</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">WS</span> <span class="o">=</span> <span class="n">WM</span><span class="o">+</span><span class="n">WA</span><span class="o">+</span><span class="n">WB</span>                
                <span class="n">WS</span> <span class="o">+=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">WS</span><span class="p">)</span><span class="o">*</span><span class="mf">1e-12</span> <span class="c1"># for numerical stability, but this may be leading to issues</span>
                <span class="n">WM</span> <span class="o">/=</span> <span class="n">WS</span>
                <span class="n">WA</span> <span class="o">/=</span> <span class="n">WS</span>
                <span class="n">WB</span> <span class="o">/=</span> <span class="n">WS</span>
                <span class="c1"># todo think gabout MAP EM instead of ML EM, some dirichlet prior                </span>
                <span class="c1"># note, I seem to be getting black in my mask, why would it be black?</span>
                



        <span class="c1"># matching cost        </span>
        <span class="c1"># note the N here is the number of pixels (actually the sum of W0)</span>
        <span class="k">if</span> <span class="n">update_sigmaM</span><span class="p">:</span>
            <span class="c1"># log det sigma, when it is unknown</span>
            <span class="n">EM</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">priors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">sigmaM</span><span class="p">))</span>
            <span class="c1"># Note in my derivation sigmaM is defined with a factor of prod dJ at the end</span>
            <span class="c1"># but everywhere it is used, except here, it gets divided by that factor</span>
            <span class="c1"># here including the factor just becomes another term in the sum, so I don&#39;t think I actually need it anywhere</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sum of squares when it is known (note sseM includes weights)</span>
            <span class="n">EM</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sseM</span><span class="o">/</span><span class="n">sigmaM</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">DJ</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="c1"># here I have a DJ</span>
        
        
        <span class="c1"># reg cost (note that with no complex, there are two elements on the last axis)</span>
        <span class="c1">#version_num = int(torch.__version__.split(&#39;.&#39;)[1])</span>
        <span class="c1">#version_num = float(&#39;.&#39;.join( torch.__version__.split(&#39;.&#39;)[:2] ))</span>
        <span class="n">version_num</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">torch</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">version_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">version_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">vhat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#vhat = torch.view_as_real(torch.fft.fftn(v,dim=3,norm=&quot;backward&quot;))</span>
            <span class="c1"># dec 14, I don&#39;t think the above is correct, need to tform over dim 2,3,4 (zyx)</span>
            <span class="c1"># note that &quot;as real&quot; gives real and imaginary as a last index</span>
            <span class="n">vhat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">view_as_real</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)))</span>
        
        <span class="n">ER</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vhat</span><span class="o">**</span><span class="mi">2</span><span class="p">,(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="n">LL</span><span class="p">)</span><span class="o">/</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">nv</span><span class="p">)</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dv</span><span class="p">)</span><span class="o">/</span><span class="n">nt</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">sigmaR</span><span class="o">**</span><span class="mi">2</span>
        

        <span class="c1"># total cost </span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">EM</span> <span class="o">+</span> <span class="n">ER</span>
        

        <span class="c1"># gradient</span>
        <span class="n">E</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>

        <span class="c1"># covector to vector</span>
        <span class="k">if</span> <span class="n">version_num</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">version_num</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="n">vgrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">KK</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="n">onesided</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1">#vgrad = torch.view_as_real(torch.fft.ifftn(torch.fft.fftn(v.grad,dim=3,norm=&quot;backward&quot;)*(KK),</span>
            <span class="c1">#    dim=3,norm=&quot;backward&quot;))</span>
            <span class="c1">#vgrad = vgrad[...,0]</span>
            <span class="c1"># dec 14, 2021 I don&#39;t think the above is correct, re dim</span>
            <span class="n">vgrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">grad</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">KK</span><span class="p">),</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span><span class="o">.</span><span class="n">real</span>
            
        <span class="c1"># Agrad = (gi@(A.grad[:3,:4].reshape(-1).to(dtype=torch.double))).reshape(3,4)</span>
        <span class="n">Agrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">A</span><span class="o">.</span><span class="n">grad</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="c1"># A2dgrad = (g2di@(A2d.grad[:,:2,:3].reshape(A2d.shape[0],6,1).to(dtype=torch.double))).reshape(A2d.shape[0],2,3)</span>
            <span class="n">A2dgrad</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">g2d</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">),</span> <span class="n">A2d</span><span class="o">.</span><span class="n">grad</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">double</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            

        <span class="c1"># plotting</span>
        <span class="n">Esave</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">E</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">EM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">ER</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()])</span>        
        <span class="n">Tsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">Lsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="n">maxvsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()))</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
            <span class="n">T2dsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
            <span class="n">L2dsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>
        <span class="c1"># a nice check on step size would be to see if these are oscilating or monotonic</span>
        <span class="k">if</span> <span class="n">n_reduce_step</span> <span class="ow">and</span> <span class="p">(</span><span class="n">it</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">n_reduce_step</span><span class="p">):</span>
            
            <span class="n">checksign0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">checksign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">checksign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxvsave</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">checksign0</span> <span class="o">!=</span> <span class="n">checksign1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">checksign1</span> <span class="o">!=</span> <span class="n">checksign2</span><span class="p">)</span> <span class="p">):</span>
                <span class="n">ev</span> <span class="o">*=</span> <span class="n">reduce_factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1"> reducing ev to </span><span class="si">{</span><span class="n">ev</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">checksign0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">checksign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">checksign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Tsave</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">reducedA</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">checksign0</span> <span class="o">!=</span> <span class="n">checksign1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">checksign1</span> <span class="o">!=</span> <span class="n">checksign2</span><span class="p">)):</span>
                <span class="n">eA</span> <span class="o">*=</span> <span class="n">reduce_factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">, translation oscilating, reducing eA to </span><span class="si">{</span><span class="n">eA</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">reducedA</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">checksign0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">checksign1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">checksign2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">Lsave</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span> <span class="p">(</span><span class="n">checksign0</span> <span class="o">!=</span> <span class="n">checksign1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">checksign1</span> <span class="o">!=</span> <span class="n">checksign2</span><span class="p">)</span> <span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">reducedA</span><span class="p">:</span>
                <span class="n">eA</span> <span class="o">*=</span> <span class="n">reduce_factor</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Iteration </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">, linear oscilating, reducing eA to </span><span class="si">{</span><span class="n">eA</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="c1"># to do, check sign for a2d</span>

        
        <span class="k">if</span> <span class="n">n_draw</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">n_draw</span> <span class="ow">or</span> <span class="n">it</span><span class="o">==</span><span class="n">n_iter</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="c1">#print(A)</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1">#axE[0].plot(np.array(Esave)[:,2])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Energy&#39;</span><span class="p">)</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Matching&#39;</span><span class="p">)</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Esave</span><span class="p">)[:,</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">axE</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Reg&#39;</span><span class="p">)</span>


            
            <span class="c1"># TODO</span>
            <span class="c1"># if slice matching, it would be better to see the reconstructed version</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_matching</span><span class="p">:</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figI</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminI</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxI</span><span class="p">)</span>
                <span class="n">figI</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;AphiI&#39;</span><span class="p">)</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">fAphiI</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figfI</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminJ</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxJ</span><span class="p">)</span>
                <span class="n">figfI</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;fAphiI&#39;</span><span class="p">)</span>     
                
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">fAphiI</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="o">-</span> <span class="n">J</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figErr</span><span class="p">)</span>
                <span class="n">figErr</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Err&#39;</span><span class="p">)</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figJ</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminJ</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxJ</span><span class="p">)</span>
                <span class="n">figJ</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>                                     
                <span class="c1"># find a sampling grid</span>
                <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
                <span class="n">meanshift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A2di</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">xJshift</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
                <span class="n">xJshift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meanshift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">xJshift</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">meanshift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">XJshift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xJshift</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
                <span class="n">XJ_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJshift</span><span class="p">)</span>
                <span class="c1"># leave z component the same (x0) and transform others                   </span>
                <span class="n">XJ_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XJshift</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>      
                <span class="n">RiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">XJ_</span><span class="p">)</span>
                
                <span class="n">Xs_</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJshift</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">phiiAi_</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs_</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs_</span>
        
                <span class="c1"># transform image</span>
                <span class="n">AphiI_</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phiiAi_</span><span class="p">)</span>                
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI_</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJshift</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figI</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminI</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxI</span><span class="p">)</span>
                <span class="n">figI</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;AphiI&#39;</span><span class="p">)</span>
                
                <span class="n">fAphiI_</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">fAphiI</span><span class="p">,</span><span class="n">XJ_</span><span class="p">)</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">fAphiI_</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJshift</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figfI</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminJ</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxJ</span><span class="p">)</span>
                <span class="n">figfI</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;fAphiI&#39;</span><span class="p">)</span>  
                
                
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">fAphiI_</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="o">-</span> <span class="n">RiJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJshift</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figErr</span><span class="p">)</span>
                <span class="n">figErr</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Err&#39;</span><span class="p">)</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">RiJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figJ</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">vminJ</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">vmaxJ</span><span class="p">)</span>
                <span class="n">figJ</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;RiJ&#39;</span><span class="p">)</span>
            
            

            <span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Tsave</span><span class="p">))</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Lsave</span><span class="p">))</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">maxvsave</span><span class="p">))</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;maxv&#39;</span><span class="p">)</span>

            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sigmaMsave</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sigmaAsave</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">sigmaBsave</span><span class="p">)</span>
            <span class="n">axA</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;sigma&#39;</span><span class="p">)</span>


            <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T2dsave</span><span class="p">))</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;T2d&#39;</span><span class="p">)</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">L2dsave</span><span class="p">))</span>
                <span class="n">axA2d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;L2d&#39;</span><span class="p">)</span>


            <span class="n">figV</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">(),</span><span class="n">xv</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figV</span><span class="p">)</span>
            <span class="n">figV</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;velocity&#39;</span><span class="p">)</span>

            <span class="n">figW</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">,</span><span class="n">WA</span><span class="o">*</span><span class="n">W0</span><span class="p">,</span><span class="n">WB</span><span class="o">*</span><span class="n">W0</span><span class="p">)),</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">figW</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
            <span class="n">figW</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Weights&#39;</span><span class="p">)</span>

            <span class="n">figE</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figI</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figfI</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figErr</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figA</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figV</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figW</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">figJ</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
                <span class="n">figA2d</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>


        <span class="c1"># update</span>
        
        <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
            <span class="c1"># here we&#39;ll do an automatic step size estimation for e based on a quadratic/Gauss-newton approximation</span>
            <span class="c1"># e1 = -int  err*DI*grad  dx/sigmaM**2  + int (Lv)*(Lgrad)dx/sigmaR**2</span>
            <span class="c1"># e2 = int  |DI*grad|^2  dx/sigmaM**2  + int (Lgrad)*(Lgrad)dx/sigmaR**2</span>
            <span class="c1"># e = e1/e2</span>
            <span class="c1"># what do I need to do to implement this?</span>
            <span class="c1"># the only tricky thing is to resample grad onto the same grid as J            </span>
            <span class="k">if</span> <span class="n">auto_stepsize_v</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">auto_stepsize_v</span><span class="p">:</span>
                <span class="c1"># WORKING</span>
                <span class="c1"># first we need to deal with the affine</span>
                <span class="c1"># we will transform J and fAphiI and W back to the space of I</span>
                <span class="n">Xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XI</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">AiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span>
                <span class="n">fphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">fAphiI</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span>
                <span class="n">AiW</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">WM</span><span class="o">*</span><span class="n">W0</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span>
                <span class="c1"># now we need DI</span>
                <span class="n">DfphiI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">fphiI</span><span class="p">,</span><span class="n">dxI</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                
            
            
            <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;=</span> <span class="n">v_start</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">-=</span> <span class="n">vgrad</span><span class="o">*</span><span class="n">ev</span>
            <span class="n">v</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
            
            <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">Agrad</span><span class="o">*</span><span class="n">eA</span>
            <span class="k">if</span> <span class="n">Amode</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># 1 means rigid</span>
                <span class="c1"># TODO update this with center of mass</span>
                <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">VH</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="nd">@VH</span>
            <span class="k">elif</span> <span class="n">Amode</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># 2 means rigid + scale</span>
                <span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">VH</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">U</span><span class="nd">@VH</span><span class="p">)</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">S</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">Amode</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1"># 0 means nothing</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Amode must be 0 (normal), 1 (rigid), or 2 (rigid+scale)&#39;</span><span class="p">)</span>
            <span class="n">A</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
                
                <span class="c1"># project A to isotropic and normal up</span>
                <span class="c1"># isotropic (done, really where is normal up?)</span>
                <span class="c1"># TODO normal                </span>
                <span class="c1"># what I really should do is parameterize this group and work out a metric                                </span>
                <span class="n">u</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">vh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">slice_matching_isotropic</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="nd">@s@vh</span>  <span class="c1"># why transpose? torch svd does not return the transpose, but this will be deprecated (fixed)</span>
                
                <span class="k">if</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">slice_matching_start</span><span class="p">:</span>
                    <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">A2dgrad</span><span class="o">*</span><span class="n">eA2d</span> <span class="c1"># already scaled</span>
                
                
                <span class="n">A2d</span><span class="o">.</span><span class="n">grad</span><span class="o">.</span><span class="n">zero_</span><span class="p">()</span>
                
                
                <span class="c1"># project onto rigid</span>
                <span class="c1">#u,s,v_ = torch.svd(A2d[:,:2,:2])</span>
                <span class="c1">#A2d[:,:2,:2] = u@v_.transpose(1,2)</span>
                <span class="c1">#A2d.grad.zero_()</span>
                
                
                <span class="c1"># TODO, when not centered at origin, I may need a different projection (see procrustes)</span>
                <span class="c1"># Let X be the voxel locations in the target image J</span>
                <span class="c1"># then let A2dX = Y be the transformed voxel locations with a nonrigid transform</span>
                <span class="c1"># then we want to find R to minimize |RX - Y|^2</span>
                <span class="c1"># this is done in 2 steps, first we center</span>
                <span class="c1"># then we svd</span>
                
                <span class="c1"># these are the untransformed points</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                
                <span class="c1"># these are the transformed points Y</span>
                <span class="c1"># we will need to update this, otherwise I&#39;m just projecting onto the same one as last time</span>
                <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span> 
                <span class="n">Y</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>                            
                <span class="c1"># for linear algebra, vector components at end</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
                <span class="c1"># we want to find a rigid transform of X to match Y (sum over row and column)</span>
                <span class="n">Xbar</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">Ybar</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">Xbar</span>
                <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">Ybar</span>
                <span class="c1"># now we want to find the best rotation that matches X to Y</span>
                <span class="c1"># we want</span>
                <span class="c1"># min |RX - Y|^2</span>
                <span class="c1"># min tr[(RX-Y)(RX-Y)^T]</span>
                <span class="c1"># min -tr[RXY^T]</span>
                <span class="c1"># max tr[R(XY^T)]</span>
                <span class="c1"># let XY^T = USV^T</span>
                <span class="c1"># then</span>
                <span class="c1"># max tr[R (USV^T)]</span>
                <span class="c1"># max tr[(V^T R U) S]</span>
                <span class="c1"># this is maximized when the bracketted term is identity</span>
                <span class="c1"># so V^T R U = id</span>
                <span class="c1"># R = V U^T</span>
                <span class="c1"># note xyz is first dimension, I will want it to be last</span>
                <span class="c1"># for tanslation</span>
                <span class="c1"># now I need the translation part</span>
                <span class="c1"># but this should just be</span>
                <span class="c1"># R(X-Xbar) = (Y-Ybar)</span>
                <span class="c1"># RX - RXbar = Y-Ybar</span>
                <span class="c1"># RX + [-RXbar + Ybar] = Y</span>
                <span class="n">S</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">U</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">Vh</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
                <span class="c1">#R = U.transpose(-1,-2)@Vh.transpose(-1,-2)</span>
                <span class="c1">#R = R.transpose(-1,-2) # ? this seems to work</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">Vh</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="nd">@U</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">T</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,]</span><span class="nd">@Xbar</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ybar</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="c1"># now we need to stack them together</span>
                <span class="n">A2di_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                <span class="n">A2di_</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span>
                <span class="n">A2di_</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span>
                <span class="n">A2di_</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">A2d</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A2di_</span><span class="p">)</span>
                
            
            
                
                
                
                <span class="c1"># move any xy translation into 2d</span>
                <span class="c1"># to do this I will have to account for any linear transformation</span>
                <span class="n">vec</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">A2di</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@vec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                
                <span class="k">if</span> <span class="n">up_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1">#print(up_vector)</span>
                    <span class="c1"># what direction does the up vector point now?</span>
                    <span class="n">new_up</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@up_vector</span>
                    <span class="c1">#print(new_up)</span>
                    <span class="c1"># now we ignore the z component</span>
                    <span class="n">new_up_2d</span> <span class="o">=</span> <span class="n">new_up</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="c1">#print(new_up_2d)</span>
                    <span class="c1"># we&#39;ll find the rotation angle, with respect to the -y axis</span>
                    <span class="c1"># use standard approach to find angle from x axis, and add 90 deg</span>
                    <span class="n">angle</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">new_up_2d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">new_up_2d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="c1"># of the form x y (TODO double check)</span>
                    <span class="c1">#print(angle*180/np.pi)</span>
                    <span class="c1"># form a rotation matrix by the negative of this angle</span>
                    <span class="n">rot</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="n">torch</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="mf">0.0</span><span class="p">],[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">]],</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
                    <span class="c1">#print(rot)</span>
                    <span class="c1"># now we have to apply this matrix to the 3D (on the left)</span>
                    <span class="c1"># and its inverse to the 2D (on the right)</span>
                    <span class="c1"># so they will cancel out</span>
                    <span class="c1"># BUT, what do I do about the translation?</span>
                    <span class="c1"># of course, I can add a translation to rot</span>
                    <span class="c1"># but do to the above issue (no xy translation on A), I think it should just be zero</span>
                    
                    <span class="c1">#print(&#39;A before&#39;,A)</span>
                    <span class="n">A</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">rot</span><span class="nd">@A</span>
                    <span class="c1">#print(&#39;A after&#39;,A)</span>
                    <span class="c1">#print(torch.linalg.inv(rot)[1:,1:])</span>
                    <span class="n">A2d</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">A2d</span><span class="nd">@torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">rot</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="c1">#double check</span>
                    <span class="c1">#print(&#39;test up&#39;,A[:3,:3]@up_vector)</span>
                    <span class="c1"># I expect this should now point exactly up</span>
                    <span class="c1"># but it seems to not</span>
                    
                    
            

            <span class="c1"># other terms in m step, these don&#39;t actually matter until I update</span>
            <span class="n">WAW0</span> <span class="o">=</span> <span class="p">(</span><span class="n">WA</span><span class="o">*</span><span class="n">W0</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">WAW0s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WAW0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">update_muA</span><span class="p">:</span>
                <span class="n">muA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">J</span><span class="o">*</span><span class="n">WAW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WAW0s</span>
            <span class="k">if</span> <span class="n">update_sigmaA</span><span class="p">:</span>
                <span class="n">sigmaA</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>  <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuA2</span><span class="o">*</span><span class="n">WAW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WAW0s</span>  <span class="p">)</span> 
            <span class="n">sigmaAsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmaA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

            <span class="n">WBW0</span> <span class="o">=</span> <span class="p">(</span><span class="n">WB</span><span class="o">*</span><span class="n">W0</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span>
            <span class="n">WBW0s</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">WBW0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">update_muB</span><span class="p">:</span>
                <span class="n">muB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">J</span><span class="o">*</span><span class="n">WBW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WBW0s</span>
            <span class="k">if</span> <span class="n">update_sigmaB</span><span class="p">:</span>
                <span class="n">sigmaB</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">JmmuB2</span><span class="o">*</span><span class="n">WBW0</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span><span class="o">/</span><span class="n">WBW0s</span><span class="p">)</span>
            <span class="n">sigmaBsave</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sigmaB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="mi">10</span><span class="p">:</span>
            <span class="c1"># todo print other info</span>
            <span class="c1">#print(f&#39;Finished iteration {it}&#39;)</span>
            <span class="k">pass</span>
            
    <span class="c1"># outputs</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span><span class="n">A</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
           <span class="s1">&#39;v&#39;</span><span class="p">:</span><span class="n">v</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span>
           <span class="s1">&#39;xv&#39;</span><span class="p">:[</span><span class="n">x</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xv</span><span class="p">]}</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A2d</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">full_outputs</span><span class="p">:</span>
        <span class="c1"># other data I may need</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">WB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;W0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">W0</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;muB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">muB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;muA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">muA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;sigmaB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaB</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;sigmaA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaA</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">out</span><span class="p">[</span><span class="s1">&#39;sigmaM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmaM</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">order</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;coeffs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="c1"># return figures</span>
        <span class="k">if</span> <span class="n">n_draw</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figA</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figE</span>
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figI</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figfI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figfI</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figErr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figErr</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figJ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figJ</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figW</span>        
            <span class="n">out</span><span class="p">[</span><span class="s1">&#39;figV&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">figV</span>        
        <span class="c1"># others ...</span>
    <span class="k">return</span> <span class="n">out</span></div>




    
    
    
<span class="c1"># everything in the config will be either a list of the same length as downI</span>
<span class="c1"># or a list of length 1</span>
<span class="c1"># or a scalar </span>
<div class="viewcode-block" id="emlddmm_multiscale"><a class="viewcode-back" href="../emlddmm.html#emlddmm.emlddmm_multiscale">[docs]</a><span class="k">def</span> <span class="nf">emlddmm_multiscale</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Run the emlddmm algorithm multiple times, restarting </span>
<span class="sd">    with the results of the previous iteration. This is intended</span>
<span class="sd">    to be used to register data from coarse to fine resolution.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emlddmm parameters either as a list of length 1 (to use the same value</span>
<span class="sd">    at each iteration) or a list of length N (to use different values at </span>
<span class="sd">    each of the N iterations).</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A list of emlddmm outputs (see documentation for emlddmm)</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># how many levels?</span>
    <span class="c1"># note I expect downI to be either a list, or a list of lists, not numpy array</span>
    <span class="k">if</span> <span class="s1">&#39;downI&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">downI</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span>        
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">downI</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">nscales</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">downI</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nscales</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found </span><span class="si">{</span><span class="n">nscales</span><span class="si">}</span><span class="s1"> scales&#39;</span><span class="p">)</span>
        
        
    
    <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nscales</span><span class="p">):</span>
        <span class="c1"># now we have to convert the kwargs to a new dictionary with only one value</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                        
            
            <span class="c1"># general cases</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># not a list, e.g. inputing v as a numpy array</span>
                <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span>            
        
        <span class="k">if</span> <span class="s1">&#39;sigmaM&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;sigmaM&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;sigmaB&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;sigmaB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mf">2.0</span>
        <span class="k">if</span> <span class="s1">&#39;sigmaA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;sigmaA&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="mf">5.0</span>
        <span class="c1">#print(f&#39;starting emlddmm with params&#39;)</span>
        <span class="c1">#print(params)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">emlddmm</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># I should save an output at each iteration</span>
        <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
        
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="s1">&#39;slice_matching&#39;</span> <span class="ow">in</span> <span class="n">params</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="s1">&#39;slice_matching&#39;</span><span class="p">]:</span>
            <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">A2d</span>
        
    <span class="k">return</span> <span class="n">outputs</span> <span class="c1"># should I return the whole list outputs?</span></div>

    
<span class="c1"># we need to output the transformations as vtk, with their companion jsons (TODO)</span>
<span class="c1"># note Data with implicit topology (structured data such as vtkImageData and vtkStructuredGrid) </span>
<span class="c1"># are ordered with x increasing fastest, then y,thenz .</span>
<span class="c1"># this is notation, it means they expect first index fastest in terms of their notation</span>
<span class="c1"># I am ignoring the names xyz, and just using fastest to slowest</span>
<span class="c1"># note dataTypeis  one  of  the  types</span>
<span class="c1"># bit,unsigned_char,char,unsigned_short,short,unsigned_int,int,unsigned_long,long,float,ordouble.</span>
<span class="c1"># I should only need the latter 2</span>
<span class="n">dtypes</span> <span class="o">=</span> <span class="p">{</span>    
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">):</span><span class="s1">&#39;float&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">):</span><span class="s1">&#39;double&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_char&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_short&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_int&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">):</span><span class="s1">&#39;unsigned_long&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">):</span><span class="s1">&#39;char&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">):</span><span class="s1">&#39;short&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">):</span><span class="s1">&#39;int&#39;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">):</span><span class="s1">&#39;long&#39;</span><span class="p">,</span>
    <span class="p">}</span>


<div class="viewcode-block" id="write_vtk_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_vtk_data">[docs]</a><span class="k">def</span> <span class="nf">write_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    Write data as vtk file legacy format file. Note data is written in big endian.</span>
<span class="sd">    </span>
<span class="sd">    inputs should be numpy, but will check for tensor</span>
<span class="sd">    only structured points supported, scalars or vectors data type</span>
<span class="sd">    each channel is saved as a dataset (time for velocity field, or image channel for images)</span>
<span class="sd">    each channel is saved as a structured points with a vector or a scalar at each point        </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        filename to write to</span>
<span class="sd">    x : list of arrays</span>
<span class="sd">        Voxel locations along last three axes</span>
<span class="sd">    out : numpy array</span>
<span class="sd">        Imaging data to write out. If out is size nt x 3 x slices x height x width we assume vector</span>
<span class="sd">        if out is size n x slices x height x width we assume scalar     </span>
<span class="sd">    title : str</span>
<span class="sd">        Name of the dataset</span>
<span class="sd">    names : list of str or None</span>
<span class="sd">        List of names for each dataset or None to use a default.        </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If out is not the right size.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;VECTORS&#39;</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="s1">&#39;SCALARS&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;out is not the right size&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;data_</span><span class="si">{</span><span class="n">t</span><span class="si">:</span><span class="s1">03d</span><span class="si">}</span><span class="s1">(b)&#39;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># make sure we know it is big endian</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">if</span> <span class="s1">&#39;(b)&#39;</span> <span class="ow">in</span> <span class="n">n</span> <span class="k">else</span> <span class="n">n</span><span class="o">+</span><span class="s1">&#39;(b)&#39;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
        
        

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>        
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">([</span>
            <span class="s1">&#39;# vtk DataFile Version 3.0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="n">title</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;BINARY</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="s1">&#39;DATASET STRUCTURED_POINTS</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;DIMENSIONS </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;ORIGIN </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;SPACING </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s1">&#39;POINT_DATA </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>                  
            <span class="p">])</span>
    
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;at&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">([</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">type_</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">dtypes</span><span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">])</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;ab&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1"># make sure big endian </span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s1">&#39;VECTORS&#39;</span><span class="p">:</span>
                <span class="c1"># put the vector component at the end</span>
                <span class="c1"># on march 29, 2022, daniel flips zyx to xyz</span>
                <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;LOOKUP_TABLE default</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
                <span class="n">out_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">outtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">out_</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
            <span class="n">out_</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">outtype</span><span class="p">)</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;at&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">([</span>
                <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="p">])</span></div>
            
<span class="n">dtypes_reverse</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;float&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">),</span>
    <span class="s1">&#39;double&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_char&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_short&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint16&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_int&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint32&#39;</span><span class="p">),</span>
    <span class="s1">&#39;unsigned_long&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;uint64&#39;</span><span class="p">),</span>
    <span class="s1">&#39;char&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int8&#39;</span><span class="p">),</span>
    <span class="s1">&#39;short&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int16&#39;</span><span class="p">),</span>
    <span class="s1">&#39;int&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int32&#39;</span><span class="p">),</span>
    <span class="s1">&#39;long&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">),</span>
<span class="p">}</span>    
<div class="viewcode-block" id="read_vtk_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_vtk_data">[docs]</a><span class="k">def</span> <span class="nf">read_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">endian</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read vtk structured points legacy format data.</span>
<span class="sd">    </span>
<span class="sd">    Note endian should always be big, but we support little as well.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Name of .vtk file to read.</span>
<span class="sd">    normalize : bool</span>
<span class="sd">        Whether or not to divide an image by its mean absolute value. Defaults to True.</span>
<span class="sd">    endian : str</span>
<span class="sd">        Endian of data, with &#39;b&#39; for big (default and only officially supported format)</span>
<span class="sd">        or &#39;l&#39; for little (for compatibility if necessary).</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        Location of voxels along each spatial axis (last 3 axes)</span>
<span class="sd">    images : numpy array</span>
<span class="sd">        Image with last three axes corresponding to spatial dimensions.  If 4D,</span>
<span class="sd">        first axis is channel.  If 5D, first axis is time, and second is xyz </span>
<span class="sd">        component of vector field.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        The first line should include vtk DataFile Version X.X</span>
<span class="sd">    Exception</span>
<span class="sd">        If the file contains data type other than BINARY.</span>
<span class="sd">    Exception</span>
<span class="sd">        If the dataset type is not STRUCTURED_POINTS.</span>
<span class="sd">    Exception</span>
<span class="sd">        If the dataset does not have either 3 or 4 axes.</span>
<span class="sd">    Exception</span>
<span class="sd">        If dataset does not contain POINT_DATA</span>
<span class="sd">    Exception</span>
<span class="sd">        If the file does not contain scalars or vectors.</span>
<span class="sd">    </span>
<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    If data not written in big endian</span>
<span class="sd">        Note (b) symbol not in data name {name}, you should check that it was written big endian. Specify endian=&quot;l&quot; if you want little</span>
<span class="sd">        </span>
<span class="sd">    TODO</span>
<span class="sd">    ----</span>
<span class="sd">    Torch does not support negative strides.  This has lead to an error where x has a negative stride.</span>
<span class="sd">    I should flip instead of negative stride, or copy afterward.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># TODO support skipping blank lines</span>
    <span class="n">big</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">endian</span><span class="o">==</span><span class="s1">&#39;l&#39;</span><span class="p">)</span>
    
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>        
        <span class="c1"># first line should say vtk version</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;vtk datafile&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;first line should include vtk DataFile Version X.X&#39;</span><span class="p">)</span>
        <span class="c1"># second line says title    </span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">line</span>

        <span class="c1"># third line should say type of data</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;BINARY&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only BINARY data type supported, but this file contains </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">data_format</span> <span class="o">=</span> <span class="n">line</span>

        <span class="c1"># next line says type of data</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;DATASET STRUCTURED_POINTS&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only STRUCTURED_POINTS dataset supported, but this file contains </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">line</span>

        <span class="c1"># next line says dimensions    </span>
        <span class="c1"># &quot;ordered with x increasing fastest, theny,thenz&quot;</span>
        <span class="c1"># this is the same as nrrd (fastest to slowest)</span>
        <span class="c1"># however our convention in python that we use channel z y x order</span>
        <span class="c1"># i.e. the first is channel</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">dimensions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only datasets with 3 or 4 axes supported, but this file contains </span><span class="si">{</span><span class="n">dimensions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># next says origin</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="c1"># next says spacing</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>

        <span class="c1"># now I can build axes</span>
        <span class="c1"># note I have to reverse the order for python</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="o">+</span><span class="n">o</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">spacing</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">origin</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>

        <span class="c1"># next line must contain point_data</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;POINT_DATA&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;only POINT_DATA supported but this file contains </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>                          
        <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># now we will loop over available datasets</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            
            <span class="c1"># first line contains data type (scalar or vector), name, and format</span>
            <span class="c1"># it could be a blank line</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>        
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            
            <span class="k">if</span> <span class="n">line</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span> <span class="c1"># check if we&#39;ve reached the end of the file</span>
                <span class="k">break</span>
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;starting to load dataset </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>            
            <span class="n">S_V</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">S_V</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;SCALARS&#39;</span><span class="p">,</span><span class="s1">&#39;VECTORS&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only scalars or vectors supported but this file contains </span><span class="si">{</span><span class="n">S_V</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>        
            
            <span class="k">if</span> <span class="s1">&#39;(b)&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">big</span><span class="p">:</span> 
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Note (b) symbol not in data name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">, you should check that it was written big endian. Specify endian=&quot;l&quot; if you want little&#39;</span><span class="p">)</span>
                            
            <span class="n">dtype_numpy</span> <span class="o">=</span> <span class="n">dtypes_reverse</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">big</span><span class="p">:</span>
                <span class="n">dtype_numpy_big</span> <span class="o">=</span> <span class="n">dtype_numpy</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span> <span class="c1"># &gt; means big endian</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype_numpy_big</span> <span class="o">=</span> <span class="n">dtype_numpy</span>
            <span class="c1">#</span>
            <span class="c1"># read the data</span>
            <span class="k">if</span> <span class="n">S_V</span> <span class="o">==</span> <span class="s1">&#39;SCALARS&#39;</span><span class="p">:</span>
                <span class="c1"># there should be a line with lookup table</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dtype_numpy_big</span><span class="p">,</span><span class="n">N</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_numpy</span><span class="p">)</span>
                <span class="c1"># shape it</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dimensions</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># axis order is already correct because of slowest to fastest convention in numpy</span>

            <span class="k">elif</span> <span class="n">S_V</span> <span class="o">==</span> <span class="s1">&#39;VECTORS&#39;</span><span class="p">:</span>            
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">dtype_numpy_big</span><span class="p">,</span><span class="n">N</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_numpy</span><span class="p">)</span>
                <span class="c1"># shape it</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span><span class="n">dimensions</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span><span class="mi">3</span><span class="p">))</span>
                <span class="c1"># move vector components first</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
                <span class="c1"># with vector data we should flip xyz (file) to zyx (python) (added march 29)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="c1"># stack on axis 0</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">images</span><span class="p">))</span> <span class="c1"># normalize</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span></div>
    
    
<div class="viewcode-block" id="read_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_data">[docs]</a><span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read array data from several file types.</span>
<span class="sd">    </span>
<span class="sd">    This function will read array based data of several types</span>
<span class="sd">    and output x,images,title,names. Note we prefer vtk legacy format, </span>
<span class="sd">    but accept some other formats as read by nibabel.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename (full path or relative) of array data to load. Can be .vtk or </span>
<span class="sd">        nibabel supported formats (e.g. .nii)</span>
<span class="sd">    x : list of arrays, optional</span>
<span class="sd">        Coordinates for 2D series space</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Keyword parameters that are passed on to the loader function</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    </span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        Pixel locations where each element of the list identifies pixel</span>
<span class="sd">        locations in corresponding axis.</span>
<span class="sd">    images : numpy array</span>
<span class="sd">        Imaging data of size channels x slices x rows x cols, or of size</span>
<span class="sd">        time x 3 x slices x rows x cols for velocity fields</span>
<span class="sd">    title : str</span>
<span class="sd">        Title of the dataset (read from vtk files)        </span>
<span class="sd">    names : list of str</span>
<span class="sd">        Names of each dataset (channel or time point)</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If file type is nrrd.</span>
<span class="sd">    Exception</span>
<span class="sd">        If data is a single slice, json reader does not support it.</span>
<span class="sd">    Exception</span>
<span class="sd">        If opening with Nibabel and the affine matrix is not diagonal.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># find the extension</span>
    <span class="c1"># if no extension use slice reader</span>
    <span class="c1"># if vtk use our reader</span>
    <span class="c1"># if nrrd use nrrd</span>
    <span class="c1"># otherwise try nibabel</span>
    <span class="n">base</span><span class="p">,</span><span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.gz&#39;</span><span class="p">:</span>
        <span class="n">base</span><span class="p">,</span><span class="n">ext_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext_</span><span class="o">+</span><span class="n">ext</span>
    <span class="c1">#print(f&#39;Found extension {ext}&#39;)</span>
    
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span> <span class="o">=</span> <span class="n">load_slices</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">xJ</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span><span class="p">[</span><span class="kc">None</span><span class="p">]))</span>
        <span class="c1"># set the names, I will separate out mask later</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;red&#39;</span><span class="p">,</span><span class="s1">&#39;green&#39;</span><span class="p">,</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;slice_dataset&#39;</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.nrrd&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;opening with nrrd&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;NRRD not currently supported&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.tiff&#39;</span><span class="p">,</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span><span class="s1">&#39;.jpeg&#39;</span><span class="p">,</span><span class="s1">&#39;.png&#39;</span><span class="p">]:</span>
        <span class="c1"># 2D image file, I can specify dx and ox</span>
        <span class="c1"># or I can search for a companion file</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;opening 2D image file&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s1">&#39;ox&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No geometry information provided&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Searching for geometry information files&#39;</span><span class="p">)</span>
            <span class="n">json_name</span> <span class="o">=</span> <span class="n">fname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ext</span><span class="p">,</span><span class="s1">&#39;.json&#39;</span><span class="p">)</span>
            <span class="n">geometry_name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;geometry.csv&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">json_name</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found json sidecar&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;json reader for single slice not implemented yet&#39;</span><span class="p">)</span>            
            <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">geometry_name</span><span class="p">):</span>                
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found legacy geometry file&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">geometry_name</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                            <span class="c1">#print(line)</span>
                            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                            <span class="c1"># filename, nx,ny,nz,dx,dy,dz,ox,oy,oz</span>
                            <span class="n">nx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]])</span>
                            <span class="c1">#print(nx)</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]])</span>
                            <span class="c1">#print(dx)</span>
                            <span class="n">ox</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">7</span><span class="p">:</span><span class="mi">10</span><span class="p">]])</span>
                            <span class="c1">#print(ox)</span>
                            <span class="c1"># change xyz to zyx</span>
                            <span class="n">nx</span> <span class="o">=</span> <span class="n">nx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">dx</span> <span class="o">=</span> <span class="n">dx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">ox</span> <span class="o">=</span> <span class="n">ox</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dx</span>
                            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ox&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ox</span>                                            
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;did not found geomtry info, using some defaults&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;dx&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Voxel size dx not in keywords, using (1,1,1)&#39;</span><span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
        <span class="k">if</span> <span class="s1">&#39;ox&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Origin not in keywords, using 0 for z, and image center for xy&#39;</span><span class="p">)</span>
            <span class="n">ox</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span><span class="s1">&#39;.tiff&#39;</span><span class="p">]:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="c1"># convert to float</span>
        <span class="k">if</span> <span class="n">images</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">/</span><span class="mf">255.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="c1"># this may do nothing if it is already float</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># normalize by the mean of each channel</span>
        <span class="c1"># add leading dimensions and reshape, note offset may be none in dims 1 and 2.</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nI</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nI</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">+=</span> <span class="n">ox</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nI</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">dx</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">+=</span> <span class="n">ox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">]</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>            
        
        
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Opening with nibabel, note only 3D images supported, sform or quaternion matrix is ignored&#39;</span><span class="p">)</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">get_fdata</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">images</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="s1">&#39;normalize&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;normalize&#39;</span><span class="p">]:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">images</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">images</span><span class="p">))</span> <span class="c1"># normalize</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        A = vol.header.get_base_affine()</span>
<span class="sd">        # NOTE: february 28, 2023.  the flipping below is causing some trouble</span>
<span class="sd">        # I would like to not use the A matrix at all</span>
<span class="sd">        </span>
<span class="sd">        if not np.allclose(np.diag(np.diag(A[:3,:3])),A[:3,:3]):</span>
<span class="sd">            raise Exception(&#39;Only support diagonal affine matrix with nibabel&#39;)</span>
<span class="sd">        x = [ A[i,-1] + np.arange(images.shape[i+1])*A[i,i] for i in range(3)]</span>
<span class="sd">        for i in range(3):</span>
<span class="sd">            if A[i,i] &lt; 0:</span>
<span class="sd">                x[i] = x[i][::-1]</span>
<span class="sd">                images = np.array(np.flip(images,axis=i+1))</span>
<span class="sd">        &#39;&#39;&#39;</span>    
        <span class="c1"># instead we do this, whic his simpler</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vol</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s1">&#39;pixdim&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">d</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">d</span><span class="p">)]</span>
        
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span></div>
<div class="viewcode-block" id="write_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_data">[docs]</a><span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">    Write data</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If data is in .nii format, it must be grayscale.</span>
<span class="sd">    Exception</span>
<span class="sd">        If output is not .vtk or .nii/.nii.gz format.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    If data to be written uses extension .nii or .nii.gz</span>
<span class="sd">        Writing image in nii fomat, no title or names saved</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">base</span><span class="p">,</span><span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.gz&#39;</span><span class="p">:</span>
        <span class="n">base</span><span class="p">,</span><span class="n">ext_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">ext_</span><span class="o">+</span><span class="n">ext</span>
    <span class="c1">#print(f&#39;Found extension {ext}&#39;)</span>
    
    <span class="k">if</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
        <span class="n">write_vtk_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">out</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.nii&#39;</span> <span class="ow">or</span> <span class="n">ext</span> <span class="o">==</span> <span class="s1">&#39;.nii.gz&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Only grayscale images supported in nii format&#39;</span><span class="p">)</span>
            
        <span class="n">affine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="n">affine</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">nibabel</span><span class="o">.</span><span class="n">Nifti1Image</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">affine</span><span class="p">)</span>
        <span class="n">nibabel</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>  
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Writing image in nii fomat, no title or names saved&#39;</span><span class="p">)</span>

        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Only vtk and .nii/.nii.gz outputs supported&#39;</span><span class="p">)</span></div>
        
    

<div class="viewcode-block" id="write_matrix_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_matrix_data">[docs]</a><span class="k">def</span> <span class="nf">write_matrix_data</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">A</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write linear transforms as matrix text file.</span>
<span class="sd">    Note that in python we use zyx order, </span>
<span class="sd">    but we write outputs in xyz order</span>
<span class="sd">    </span>
<span class="sd">    Parameter</span>
<span class="sd">    ---------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename to write</span>
<span class="sd">    A : 2D array</span>
<span class="sd">        Matrix data to write. Assumed to be in zyx order.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># copy the matrix</span>
    <span class="n">A_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">A_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
    
    <span class="c1"># swap zyx -&gt; xyz, accounting for affine</span>
    <span class="n">A_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A_</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A_</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>                
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">A_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">A_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="read_matrix_data"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_matrix_data">[docs]</a><span class="k">def</span> <span class="nf">read_matrix_data</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read linear transforms as matrix text file.</span>
<span class="sd">    Note in python we work in zyx order, but text files are in xyz order</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : array</span>
<span class="sd">        matrix in zyx order</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>            
            <span class="k">if</span> <span class="s1">&#39;,&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="c1"># we expect this to be a csv</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># it may be separated by spaces</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)):</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="c1"># if it is 3x3, then i is 3</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="n">i</span><span class="p">,:</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># swap xyz -&gt; zyx, accounting for affine</span>
    <span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">A</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># make copy to avoid negative strides</span></div>



<span class="c1"># write vtk point data</span>
<div class="viewcode-block" id="write_vtk_polydata"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_vtk_polydata">[docs]</a><span class="k">def</span> <span class="nf">write_vtk_polydata</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">points</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">connectivity_type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    points should by Nx3 in zyx order</span>
<span class="sd">    It will be written out in xyz order</span>
<span class="sd">    connectivity should be lists of indices or nothing to write only cell data</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        Filename to write</span>
<span class="sd">    name : str</span>
<span class="sd">        Dataset name</span>
<span class="sd">    points : array</span>
<span class="sd">        </span>
<span class="sd">    connectivity : str</span>
<span class="sd">        Array of arrays storing each connectivity element as integers that refer to the points, </span>
<span class="sd">        size number of points by number of dimensions (expected to be 3)</span>
<span class="sd">    connectivity_type : str</span>
<span class="sd">        Can by VERTICES, or POLYGONS, or LINES</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nothing</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># first we&#39;ll open the file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# vtk DataFile Version 2.0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;ASCII</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;DATASET POLYDATA</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;POINTS </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> float</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                 
        <span class="k">if</span> <span class="p">(</span><span class="n">connectivity</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">connectivity_type</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;VERTICES&#39;</span><span class="p">):</span>
            <span class="c1"># lets try to add vertices</span>
            <span class="c1"># the second number is how many numbers are below</span>
            <span class="c1"># there is one extra number per line</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;VERTICES </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;1 </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">connectivity_type</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;POLYGONS&#39;</span><span class="p">:</span>
            <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="n">ntot</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">ntot</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;POLYGONS </span><span class="si">{</span><span class="n">nlines</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">ntot</span><span class="o">+</span><span class="n">nlines</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">connectivity_type</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;LINES&#39;</span><span class="p">:</span>
            <span class="n">nlines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">connectivity</span><span class="p">)</span>
            <span class="n">ntot</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">ntot</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LINES </span><span class="si">{</span><span class="n">nlines</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">ntot</span><span class="o">+</span><span class="n">nlines</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">connectivity</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">l</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span></div>
                

<div class="viewcode-block" id="read_vtk_polydata"><a class="viewcode-back" href="../emlddmm.html#emlddmm.read_vtk_polydata">[docs]</a><span class="k">def</span> <span class="nf">read_vtk_polydata</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read ascii vtk polydata from simple legacy files.</span>
<span class="sd">    Assume file contains xyz order, they are converted to zyx for python</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The name of the file to read</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    points : numpy float array</span>
<span class="sd">        nx3 array storing locations of points</span>
<span class="sd">    connectivity : list of lists</span>
<span class="sd">        list of indices containing connectivity elements</span>
<span class="sd">    connectivity_type : str</span>
<span class="sd">        VERTICES or LINES or POLYGONS</span>
<span class="sd">    name : str</span>
<span class="sd">        name of the dataset</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">connectivity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">connectivity_type</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">point_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">connectivity_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1">#print(line)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># this line has name</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;POINTS&#39;</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">and</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># we need to make sure we&#39;re not detecting the title</span>
                <span class="c1">#print(f&#39;found points {line}&#39;)</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">npoints</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># not using</span>
                <span class="n">point_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">point_counter</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">point_counter</span> <span class="o">&lt;</span> <span class="n">npoints</span><span class="p">:</span>
                <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())]))</span> <span class="c1"># xyz -&gt; zyx</span>
                <span class="n">point_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">point_counter</span> <span class="o">==</span> <span class="n">npoints</span><span class="p">:</span>
                    <span class="n">point_counter</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                    <span class="k">continue</span>
                    
            <span class="k">if</span> <span class="n">point_counter</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span> <span class="ow">and</span> <span class="n">connectivity_counter</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>                
                <span class="c1"># next line should say connectivity type</span>
                <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">connectivity_type</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># next number should say number of connectivity entries</span>
                <span class="n">n_elements</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">n_indices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">connectivity_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">connectivity_counter</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">connectivity_counter</span> <span class="o">&lt;</span> <span class="n">n_elements</span><span class="p">:</span>
                <span class="c1"># the first number specifies how many numbers follow</span>
                <span class="n">connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]])</span>
            
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">points</span><span class="p">),</span><span class="n">connectivity</span><span class="p">,</span><span class="n">connectivity_type</span><span class="p">,</span><span class="n">name</span></div>


<div class="viewcode-block" id="Image"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Image">[docs]</a><span class="k">class</span> <span class="nc">Image</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    space : string</span>
<span class="sd">        name of the image space</span>
<span class="sd">    name : string</span>
<span class="sd">        image name. This is provided when instantiating an Image object.</span>
<span class="sd">    x : list of numpy arrays</span>
<span class="sd">        image voxel coordinates</span>
<span class="sd">    data : numpy array</span>
<span class="sd">        image data</span>
<span class="sd">    title : string</span>
<span class="sd">        image title passed by the read_data function</span>
<span class="sd">    names : list of strings</span>
<span class="sd">        information about image data dimensions</span>
<span class="sd">    mask : array</span>
<span class="sd">        image mask</span>
<span class="sd">    path : string</span>
<span class="sd">        path to image file or directory containing the 2D image series</span>
<span class="sd">    </span>
<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    normalize(norm=&#39;mean&#39;, q=0.99)</span>
<span class="sd">        normalize image</span>
<span class="sd">    downsample(down)</span>
<span class="sd">        downsample image, image coordinated, and mask</span>
<span class="sd">    fnames()</span>
<span class="sd">        get filenames of 2D images in a series, or return the single filename of an image volume</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">space</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fpath</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        space : string</span>
<span class="sd">            Name for image space</span>
<span class="sd">        name : string</span>
<span class="sd">            Name for image</span>
<span class="sd">        fpath : string</span>
<span class="sd">            Path to image file or directory containing the 2D image series</span>
<span class="sd">        mask : numpy array, optional</span>
<span class="sd">        x : list of numpy arrays</span>
<span class="sd">            Space coordinates for 2D series</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
        <span class="c1"># I think we should check the title to see if we need to normalize</span>
        <span class="k">if</span> <span class="s1">&#39;label&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">or</span> <span class="s1">&#39;annotation&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">or</span> <span class="s1">&#39;segmentation&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Found an annotation image, not converting to float, and reloading with normalize false&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># read it again with no normalization</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">fpath</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> 
            <span class="bp">self</span><span class="o">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="kc">False</span>
                

        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">fpath</span>
        <span class="k">if</span> <span class="s1">&#39;mask&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">maskind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;mask&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">maskind</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">!=</span><span class="n">maskind</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">mask</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># only initialize mask array if mask arg is True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># normalize is now performed during data loading</span>
    <span class="k">def</span> <span class="nf">_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.99</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Normalize image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : string</span>
<span class="sd">            Takes the values &#39;mean&#39;, or &#39;quantile&#39;. Default is &#39;mean&#39;</span>
<span class="sd">        q : float</span>
<span class="sd">            Quantile used for normalization if norm is set to &#39;quantile&#39;</span>

<span class="sd">        Return</span>
<span class="sd">        ------</span>
<span class="sd">        numpy array</span>
<span class="sd">            Normalized image</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;quantile&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">norm</span><span class="si">}</span><span class="s1"> is not a valid option for the norm keyword argument.&#39;</span><span class="p">)</span>
    
<div class="viewcode-block" id="Image.downsample"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Image.downsample">[docs]</a>    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">down</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Downsample image</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        down : list of ints</span>
<span class="sd">            Factor by which to downsample along each dimension </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        x : list of numpy arrays</span>
<span class="sd">            Pixel locations where each element of the list identifies pixel</span>
<span class="sd">            locations in corresponding axis.</span>
<span class="sd">        data : numpy array</span>
<span class="sd">            image data</span>
<span class="sd">        mask : numpy array</span>
<span class="sd">            binary mask array</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">down</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span><span class="n">down</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span></div>

<div class="viewcode-block" id="Image.fnames"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Image.fnames">[docs]</a>    <span class="k">def</span> <span class="nf">fnames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Get a list of image file names for 2D series, or a single file name for volume image.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fnames : list of strings</span>
<span class="sd">            List of image file names</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">samples_tsv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;samples.tsv&quot;</span><span class="p">)</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">samples_tsv</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">count</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">line</span> <span class="k">else</span> <span class="s1">&#39;    &#39;</span>
                    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">line</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">fnames</span></div></div>
        

<div class="viewcode-block" id="fnames"><a class="viewcode-back" href="../emlddmm.html#emlddmm.fnames">[docs]</a><span class="k">def</span> <span class="nf">fnames</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Get a list of image file names for 2D series, or a single file name for volume image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fnames : list of strings</span>
<span class="sd">        List of image file names</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">samples_tsv</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;samples.tsv&quot;</span><span class="p">)</span>
        <span class="n">fnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">samples_tsv</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">count</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">line</span> <span class="k">else</span> <span class="s1">&#39;    &#39;</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">line</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">fnames</span></div>


<div class="viewcode-block" id="write_transform_outputs_"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_transform_outputs_">[docs]</a><span class="k">def</span> <span class="nf">write_transform_outputs_</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Note this version (whose function name ends in &quot;_&quot; ) is obsolete.</span>
<span class="sd">    Write transforms output from emlddmm.  Velocity field, 3D affine transform,</span>
<span class="sd">    and 2D affine transforms for each slice if applicable.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Directory to place output data (will be created of it does not exist)</span>
<span class="sd">    output : dict</span>
<span class="sd">        Output dictionary from emlddmm algorithm</span>
<span class="sd">    A2d_names : list </span>
<span class="sd">        List of file names for A2d transforms</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    Update parameter list.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">slice_outputs</span> <span class="o">=</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">output</span>
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="n">series_to_series</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">title</span> <span class="o">==</span> <span class="s1">&#39;slice_dataset&#39;</span> <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">title</span> <span class="o">==</span> <span class="s1">&#39;slice_dataset&#39;</span>
    <span class="k">if</span> <span class="n">series_to_series</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_input_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input/transforms/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">A2d_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">A2d_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_matrix.txt&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">A2d_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">A2d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span>
    
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">out3d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_registered_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>
        <span class="n">out2d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered/transforms&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out2d</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out2d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out3d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out3d</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out3d</span><span class="p">)</span>
        
    <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out3d</span><span class="p">,</span> <span class="s1">&#39;velocity.vtk&#39;</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;velocity_field&#39;</span>
    <span class="n">write_vtk_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="n">title</span><span class="p">)</span>  
    <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out3d</span><span class="p">,</span> <span class="s1">&#39;A.txt&#39;</span><span class="p">)</span>
    <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">A2d_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">A2d_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_matrix.txt&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out2d</span><span class="p">,</span> <span class="n">A2d_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">A2d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span></div>

<div class="viewcode-block" id="write_transform_outputs"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_transform_outputs">[docs]</a><span class="k">def</span> <span class="nf">write_transform_outputs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Note, daniel is redoing the above slightly. on March 2023</span>

<span class="sd">    Write transforms output from emlddmm.  Velocity field, 3D affine transform,</span>
<span class="sd">    and 2D affine transforms for each slice if applicable.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Directory to place output data (will be created of it does not exist)</span>
<span class="sd">    output : dict</span>
<span class="sd">        Output dictionary from emlddmm algorithm</span>
<span class="sd">    A2d_names : list </span>
<span class="sd">        List of file names for A2d transforms</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    Update parameter list.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
    <span class="n">slice_outputs</span> <span class="o">=</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">output</span>
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="n">series_to_series</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">title</span> <span class="o">==</span> <span class="s1">&#39;slice_dataset&#39;</span> <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">title</span> <span class="o">==</span> <span class="s1">&#39;slice_dataset&#39;</span>
    <span class="k">if</span> <span class="n">series_to_series</span><span class="p">:</span>
        <span class="c1">#out = os.path.join(output_dir, f&#39;{I.space}_input/{J.space}_{J.name}_input_to_{I.space}_input/transforms/&#39;)</span>
        <span class="c1"># danel thinks the name shouldn&#39;t go here</span>
        <span class="c1"># it should be clear from the filenames</span>
        <span class="c1">#out = os.path.join(output_dir, f&#39;{I.space}_input/{J.space}_input_to_{I.space}_input/transforms/&#39;)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">A2d_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1">#A2d_names.append(f&#39;{I.space}_input_{I.fnames()[i]}_to_{J.space}_input_{J.fnames()[i]}_matrix.txt&#39;)</span>
            <span class="n">A2d_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_matrix.txt&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">A2d_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">A2d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="k">return</span>
    
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>        
        <span class="c1">#out3d = os.path.join(output_dir, f&#39;{I.space}/{J.space}_{J.name}_registered_to_{I.space}/transforms/&#39;)</span>
        <span class="c1"># again daniel says no name here</span>
        <span class="n">out3d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>        
        <span class="c1">#out2d = os.path.join(output_dir, f&#39;{J.space}_registered/{J.space}_input_to_{J.space}_registered/transforms&#39;)</span>
        <span class="n">out2d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered/transforms&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out2d</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out2d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="c1">#out3d = os.path.join(output_dir, f&#39;{I.space}/{J.space}_{J.name}_to_{I.space}/transforms/&#39;)</span>
        <span class="c1"># again daniel says no name here</span>
        <span class="n">out3d</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/transforms/&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out3d</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out3d</span><span class="p">)</span>
        
    <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out3d</span><span class="p">,</span> <span class="s1">&#39;velocity.vtk&#39;</span><span class="p">)</span>
    <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;velocity_field&#39;</span>
    <span class="n">write_vtk_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="n">title</span><span class="p">)</span>  
    <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out3d</span><span class="p">,</span> <span class="s1">&#39;A.txt&#39;</span><span class="p">)</span>
    <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span><span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_outputs</span><span class="p">:</span>
        <span class="n">A2d_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1">#A2d_names.append(f&#39;{J.space}_registered_{J.fnames()[i]}_to_{J.space}_input_{J.fnames()[i]}_matrix.txt&#39;)</span>
            <span class="n">A2d_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">fnames</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_matrix.txt&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">A2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">output_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out2d</span><span class="p">,</span> <span class="n">A2d_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">A2d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span>    </div>


<div class="viewcode-block" id="registered_domain"><a class="viewcode-back" href="../emlddmm.html#emlddmm.registered_domain">[docs]</a><span class="k">def</span> <span class="nf">registered_domain</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">A2d</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Construct a new domain that fits all rigidly aligned slices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list of arrays</span>
<span class="sd">        list of numpy arrays containing voxel positions along each axis.</span>
<span class="sd">    A2d : numpy array</span>
<span class="sd">        Nx3x3 array of affine transformations</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr : list of arrays</span>
<span class="sd">        new list of numpy arrays containing voxel positions along each axis</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2di</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">X</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:,</span> <span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">m0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">M0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">M1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># construct a recon domain</span>
    <span class="n">dJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
    <span class="c1"># print(&#39;dJ shape: &#39;, [x.shape for x in dJ])</span>
    <span class="n">xr0</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">m0</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">M0</span><span class="p">),</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xr1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">m1</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">M1</span><span class="p">),</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">device</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">m0</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xr0</span><span class="p">,</span> <span class="n">xr1</span>

    <span class="k">return</span> <span class="n">xr</span></div>


<div class="viewcode-block" id="write_qc_outputs"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_qc_outputs">[docs]</a><span class="k">def</span> <span class="nf">write_qc_outputs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">xS</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; write out registration qc images</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_dir : string</span>
<span class="sd">        Path to output parent directory</span>
<span class="sd">    output : dict</span>
<span class="sd">        Output dictionary from emlddmm algorithm</span>
<span class="sd">    I : emlddmm image</span>
<span class="sd">        source image</span>
<span class="sd">    J : emlddmm image</span>
<span class="sd">        target image</span>
<span class="sd">    xS : list of arrays, optional</span>
<span class="sd">        Label coordinates</span>
<span class="sd">    S : array, optional</span>
<span class="sd">        Labels</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>


<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="c1">#print(f&#39;output dir is {output_dir}&#39;)</span>
    
    <span class="n">xv</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
    <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="c1">#print(A.device)</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">device</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dtype</span>
    
    <span class="c1"># to torch</span>
    <span class="n">Jdata</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">J</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
    <span class="n">Idata</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">data</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">I</span><span class="o">.</span><span class="n">x</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># segmentations go with atlas, they are integers</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> 
        <span class="c1"># don&#39;t specify dtype here, you had better set it in numpy</span>
        <span class="c1"># actually I need it as float in order to apply interp</span>
        <span class="k">if</span> <span class="n">xS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xS</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
            
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">slice_matching</span> <span class="o">=</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">output</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">A2d</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;cpu&#39;</span><span class="p">)</span>
        <span class="n">A2di</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
        <span class="n">XJ_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJ</span><span class="p">)</span>           

        <span class="n">XJ_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2di</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>            
        <span class="c1"># if registering series to series</span>
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">title</span><span class="o">==</span><span class="s1">&#39;slice_dataset&#39;</span> <span class="ow">and</span> <span class="n">J</span><span class="o">.</span><span class="n">title</span><span class="o">==</span><span class="s1">&#39;slice_dataset&#39;</span><span class="p">:</span>
            <span class="c1"># first I to J</span>
            <span class="n">AI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span> <span class="n">Idata</span><span class="p">,</span> <span class="n">XJ_</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_input_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input&#39;</span><span class="p">)</span>
            <span class="c1">#out = os.path.join(output_dir,f&#39;{J.space}_input/{I.space}_{I.name}_input_to_{J.space}_input/qc/&#39;)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Jdata</span><span class="p">,</span> <span class="n">xJ</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
            <span class="c1"># now J to I</span>
            <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
            <span class="n">XI_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XI</span><span class="p">)</span>
            <span class="n">XI_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XI</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">AiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">Jdata</span><span class="p">,</span><span class="n">XI_</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AiJ</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1">#out = os.path.join(output_dir,f&#39;{I.space}_input/{J.space}_{J.name}_input_to_{I.space}_input/qc/&#39;)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Idata</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>

            <span class="k">return</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">XJ_</span> <span class="o">=</span> <span class="n">XJ</span>

    <span class="c1"># sample points for affine</span>
    <span class="n">Xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ_</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="c1"># for diffeomorphism</span>
    <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
    <span class="n">phiiAi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs</span>
    <span class="c1"># transform image</span>
    <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">Idata</span><span class="p">,</span><span class="n">phiiAi</span><span class="p">)</span>
    <span class="c1"># target space</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_input&#39;</span><span class="p">)</span>
        <span class="c1">#out = os.path.join(output_dir,f&#39;{J.space}_input/{I.space}_{I.name}_to_{J.space}_input/qc/&#39;)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
        
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Jdata</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
        
        <span class="c1"># modify XJ by shifting by mean translation</span>
        <span class="n">mean_translation</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">A2d</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mean_translation: </span><span class="si">{</span><span class="n">mean_translation</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">XJr</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJ</span><span class="p">)</span>
        <span class="n">XJr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">mean_translation</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">xJr</span> <span class="o">=</span> <span class="p">[</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_translation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_translation</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">XJr_</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">XJr</span><span class="p">)</span>
        <span class="n">XJr_</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">XJr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Jr</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">Jdata</span><span class="p">,</span><span class="n">XJr_</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Jr</span><span class="p">,</span><span class="n">xJr</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_registered&#39;</span><span class="p">)</span>
        <span class="c1">#out = os.path.join(output_dir,f&#39;{J.space}_registered/{I.space}_{I.name}_to_{J.space}_registered/qc/&#39;)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered/</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_registered.jpg&#39;</span><span class="p">)</span>
        
        <span class="c1"># and we need atlas reconstructed in target space</span>

        <span class="c1"># sample points for affine</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJr</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="c1"># for diffeomorphism</span>
        <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="n">phiiAi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">Xs</span><span class="p">)</span> <span class="o">+</span> <span class="n">Xs</span>

        <span class="c1"># transform image</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">Idata</span><span class="p">,</span><span class="n">phiiAi</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span> <span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered.jpg&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">#out = os.path.join(output_dir,f&#39;{J.space}/{I.space}_{I.name}_to_{J.space}/qc/&#39;)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Jdata</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>
        <span class="n">Jr</span> <span class="o">=</span> <span class="n">Jdata</span>

    <span class="c1"># and source space</span>
    <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">Aphi</span> <span class="o">=</span> <span class="p">((</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@phi</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">Aphi</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span><span class="n">Aphi</span><span class="p">,</span><span class="n">XI</span><span class="p">)</span>
    <span class="c1"># apply the shift to Aphi since it was subtracted when creating Jr</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="n">Aphi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">mean_translation</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">phiiAiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">Jr</span><span class="p">,</span><span class="n">Aphi</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">phiiAiJ</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">slice_matching</span><span class="p">:</span>
        <span class="c1">#out = os.path.join(output_dir,f&#39;{I.space}/{J.space}_{J.name}_registered_to_{I.space}/qc/&#39;)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_registered_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#out = os.path.join(output_dir,f&#39;{I.space}/{J.space}_{J.name}_to_{I.space}/qc/&#39;)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">/qc/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">.jpg&#39;</span> <span class="p">)</span>


    <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">Idata</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">space</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">)</span>

    <span class="n">output_slices</span> <span class="o">=</span> <span class="n">slice_matching</span> <span class="ow">and</span> <span class="p">(</span> <span class="p">(</span><span class="n">xS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">S</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">output_slices</span><span class="p">:</span>
        <span class="c1"># transform S</span>
        <span class="c1"># note here I had previously converted it to float</span>
        <span class="n">AphiS</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xS</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span><span class="n">phiiAi</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">mods</span> <span class="o">=</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="n">AphiS</span><span class="o">%</span><span class="n">mods</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">mods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="n">AphiS</span><span class="o">%</span><span class="n">mods</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">mods</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">AphiS</span><span class="o">%</span><span class="n">mods</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">mods</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">)),</span><span class="n">xJ</span><span class="p">)</span>

        <span class="c1"># also outlines</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">AphiS</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="c1">#range(-r,r+1): # in the coronal plane my M is &quot;nice&quot;</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">j</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">AphiS</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span><span class="o">!=</span><span class="n">AphiS</span><span class="p">)</span>
        <span class="c1">#fig = draw(M[None])</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">))</span><span class="o">*</span><span class="n">M</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.99</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">(),</span><span class="n">q</span><span class="p">)</span>
        <span class="n">Jn</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jr</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Jn</span><span class="p">[</span><span class="n">Jn</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">Jn</span><span class="p">[</span><span class="n">Jn</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="n">show_</span> <span class="o">=</span> <span class="n">Jn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">M</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span> <span class="o">+</span> <span class="n">M</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">C</span><span class="o">*</span><span class="n">alpha</span>
        
        <span class="n">f</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">show_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">show_</span><span class="p">[:,</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

            <span class="n">f</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;slice_</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s1">04d</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
            <span class="c1">#f.savefig(join(to_registered_out,f&#39;{dest_space}_{dest_img}_to_{src_space}_REGISTERED_{slice_names[i]}.jpg&#39;))    </span>
            <span class="c1"># notte the above line came up in a merge conflict on march 10, 2023.  We&#39;ll consider it later.</span>
    <span class="k">return</span></div>





<div class="viewcode-block" id="Transform"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Transform">[docs]</a><span class="k">class</span> <span class="nc">Transform</span><span class="p">():</span>    
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A simple class for storing and applying transforms</span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    Note that the types of transforms we can support are</span>
<span class="sd">    </span>
<span class="sd">    #. Deformations stored as a displacement field loaded from a vtk file.  These should be a 1x3xrowxcolxslice array.</span>
<span class="sd">    #. Deformations stored as a position field in a python variable. These are a 3xrowxcolxslice array.</span>
<span class="sd">    #. Velocity fields stored as a python variable. These are ntx3xrowxcolxslice arrays.</span>
<span class="sd">    #. a 4x4 affine transform loaded from a text file.</span>
<span class="sd">    #. a 4x4 affine transform stored in a python variable</span>
<span class="sd">    #. a nslices x 3 x 3 sequence of affine transforms stored in an array. *** new and special case ***</span>

<span class="sd">    Note the data stores position fields or matrices.  If it is a vtk file it will store a position field.</span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    Raise</span>
<span class="sd">    -----</span>
<span class="sd">    Exception</span>
<span class="sd">        If transform is not a txt or vtk file or valid python variable.</span>
<span class="sd">    Exception</span>
<span class="sd">        if direction is not &#39;f&#39; or &#39;b&#39;.</span>
<span class="sd">    Exception</span>
<span class="sd">        When inputting a velocity field, if the domain is not included.</span>
<span class="sd">    Exception</span>
<span class="sd">        When inputting a matrix, if its shape is not 3x3 or 4x4.</span>
<span class="sd">    Exception</span>
<span class="sd">        When specifying a mapping, if the direction is &#39;b&#39; (backward).</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Your data is a string, attempting to load files&#39;</span><span class="p">)</span>
            <span class="c1"># If the data is a string, we assume it is a filename and load it</span>
            <span class="n">prefix</span><span class="p">,</span><span class="n">extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;.txt&#39;</span><span class="p">:</span>
<span class="w">                </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                data = np.genfromtxt(data,delimiter=&#39;,&#39;)                </span>
<span class="sd">                # note that there are nans at the end if I have commas at the end</span>
<span class="sd">                if np.isnan(data[0,-1]):</span>
<span class="sd">                    data = data[:,:data.shape[1]-1]</span>
<span class="sd">                    #print(data)</span>
<span class="sd">                &#39;&#39;&#39;</span>
                <span class="c1"># note on March 29, daniel adds the following and commented out the above</span>
                <span class="c1"># Here we load a matrix from a text file.  We will expect this to be a 4x4 matrix.</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found txt extension, loaded matrix data&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
                <span class="c1"># if it is a vtk file we will assume this is a displacement field</span>
                <span class="n">x</span><span class="p">,</span><span class="n">images</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_vtk_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">domain</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">images</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found vtk extension, loaded vtk file with size </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">extension</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># if there is no extension, we assume this is a directory containing a sequence of transformation matrices</span>
                <span class="c1"># TODO: there are a couple issues here</span>
                <span class="c1"># first we need to make sure we can sort the files in the right way.  right now its sorting based on the last 4 characters</span>
                <span class="c1"># this works for csh, but does not work in general.</span>
                <span class="c1"># second we may have two datasets mixed in, so we&#39;ll need a glob pattern.</span>
                <span class="n">transforms_ls</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_matrix.txt&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">4</span><span class="p">:])</span>
                <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms_ls</span><span class="p">:</span>
                    <span class="n">A2d</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A2d</span><span class="p">)</span>
                    <span class="c1"># converting to tensor will deal with the stacking</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found directory, loaded a series of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="si">}</span><span class="s1"> matrix files with size </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only txt and vtk files supported but your transform is </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># convert the data to a torch tensor        </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">domain</span><span class="p">]</span>            
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Direction must be </span><span class="se">\&#39;</span><span class="s1">f</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">b</span><span class="se">\&#39;</span><span class="s1"> but it was </span><span class="se">\&#39;</span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        
        <span class="c1"># if it is a velocity field we need to integrate it</span>
        <span class="c1"># if it is a displacement field, then we need to add identity to it</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found 5D dataset, this is either a displacement field or a velocity field&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># assume this is a displacement field and add identity</span>
                <span class="c1"># if it is a displacement field we cannot invert it, so we should throw an error if you use the wrong f,b</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Displacement field not supported yet&#39;</span><span class="p">)</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># assume this is a velocity field and integrate it</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Domain is required when inputting velocity field&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Integrated inverse from velocity field&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="o">-</span><span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,(</span><span class="mi">0</span><span class="p">,)))</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Integrated velocity field&#39;</span><span class="p">)</span>            
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span><span class="c1"># if it is a matrix check size</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found 2D dataset, this is an affine matrix.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;converting 2D to 3D with identity&#39;</span><span class="p">)</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">tmp</span>            
            <span class="k">elif</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Only 3x3 or 4x4 matrices supported now but this is </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="c1"># if it is a series of 2d affines, we leave them as 2d.</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found a series of 2D affines.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span> <span class="c1"># if it is a mapping</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;When specifying a mapping, backwards is not supported&#39;</span><span class="p">)</span>
                        
                
                
<div class="viewcode-block" id="Transform.apply"><a class="viewcode-back" href="../emlddmm.html#emlddmm.Transform.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># then it is a matrix</span>
            <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="k">return</span> <span class="p">((</span><span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@X</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># if it is 3D then it is a stack of 2D 3x3 affine matrices</span>
            <span class="c1"># this will only work if the input data is the right shape</span>
            <span class="c1"># ideally, I should attach a domain to it.</span>
            <span class="n">A2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">((</span><span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A2d</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># then it is a displacement field, we need interp</span>
            <span class="c1"># recall all components are stored on the first axis,</span>
            <span class="c1"># but for sampling they need to be on the last axis</span>
            <span class="n">ID</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
            <span class="c1"># print(f&#39;ID shape {ID.shape}&#39;)</span>
            <span class="c1"># print(f&#39;X shape {X.shape}&#39;)</span>
            <span class="c1"># print(f&#39;data shape {self.data.shape}&#39;)</span>

            <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">ID</span><span class="p">),</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">X</span></div>
            
                    
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Transform with data size </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">, direction </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">direction</span><span class="si">}</span><span class="s1">, and domain </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>
            
<span class="c1"># now wrap this into a function</span>
<div class="viewcode-block" id="compose_sequence"><a class="viewcode-back" href="../emlddmm.html#emlddmm.compose_sequence">[docs]</a><span class="k">def</span> <span class="nf">compose_sequence</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="n">Xin</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Compose a set of transformations, to produce a single position field, </span>
<span class="sd">    suitable for use with :func:`emlddmm.apply_transform_float` for example.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transforms : </span>
<span class="sd">        Several types of inputs are supported.</span>

<span class="sd">        #. A list of transforms class.</span>
<span class="sd">        #. A list of filenames (single direction in argument)</span>
<span class="sd">        #. A list of a list of 2 tuples that specify direction (f,b)</span>
<span class="sd">        #. An output directory</span>
<span class="sd">        </span>
<span class="sd">    Xin : 3 x slice x row x col array</span>
<span class="sd">        The points we want to transform (e.g. sample points in atlas).  Also supports input as a list of voxel locations,</span>
<span class="sd">        along each axis which will be reshaped as above using meshgrid.</span>
<span class="sd">    direction : char</span>
<span class="sd">        Can be &#39;f&#39; for foward or &#39;b&#39; for bakward.  f is default which maps points from atlas to target, </span>
<span class="sd">        or images from target to atlas.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Xout :  3 x slicex rowxcol array</span>
<span class="sd">        Points from Xin that have had a sequence of transformations applied to them.</span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Note, if the input is a string, we assume it is an output directory and get A and V. In this case we use the direction argument.</span>
<span class="sd">    If the input is a tuple of length 2, we assume it is an output directory and a direction</span>
<span class="sd">    </span>
<span class="sd">    Otherwise, the input must be a list.  It can be a list of strings, or transforms, or string-direction tuples.  </span>
<span class="sd">    </span>
<span class="sd">    We check that it is an instace of a list, so it should not be a tuple.</span>
<span class="sd">    </span>
<span class="sd">    </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        Transforms must be either output directory,</span>
<span class="sd">        or list of objects, or list of filenames,</span>
<span class="sd">        or list of tuples storing filename/direction.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    #. use os path join</span>
<span class="sd">    #. support direction as a list, right now direction only is used for a single direction</span>

<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1">#print(f&#39;starting to compose sequence with transforms {transforms}&#39;)    </span>
    
    
    <span class="c1"># check special case for a list of length 1 but the input is a directory</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> 
        <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># check special case for a list of length one but the input is a tuple</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> 
        <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> 
        <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;&#39;</span> <span class="ow">and</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="s1">&#39;f&#39;</span><span class="p">]):</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># note variable is redefined                </span>
    
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span> <span class="ow">or</span> <span class="p">(</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span> <span class="n">transforms</span> <span class="o">=</span> <span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>            
        <span class="c1"># assume output directory</span>
        <span class="c1"># print(&#39;printing transforms input&#39;)</span>
        <span class="c1"># print(transforms)</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
            <span class="c1"># backward, first affine then deform</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;A.txt&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">),</span>
                          <span class="n">Transform</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;velocity.vtk&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="c1"># forward, first deform then affine</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;velocity.vtk&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">),</span>
                          <span class="n">Transform</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">,</span><span class="s1">&#39;A.txt&#39;</span><span class="p">),</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)]</span>    
        <span class="c1">#print(&#39;printing modified transforms&#39;)</span>
        <span class="c1">#print(transforms)    </span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="c1"># there is an issue here:</span>
        <span class="c1"># when I call this from outside, the type is emlddmm.Transform, not Transform. The test fails</span>
        <span class="c1"># print(type(transforms[0]))</span>
        <span class="c1"># print(isinstance(transforms[0],Transform))</span>
        <span class="c1">#if type(transforms[0]) == Transform:</span>
        <span class="k">if</span> <span class="s1">&#39;Transform&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span> 
            <span class="c1"># this approach may fix the issue but I don&#39;t like it</span>
            <span class="c1"># I am having trouble reproducing this error on simpler examples</span>
            <span class="c1"># don&#39;t do anything here</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
            <span class="c1"># list of strings</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="n">Transform</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">direction</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Transforms must be either output directory, </span><span class="se">\</span>
<span class="s1">        or list of objects, or list of filenames, </span><span class="se">\</span>
<span class="s1">        or list of tuples storing filename/direction&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Transforms must be either output directory, </span><span class="se">\</span>
<span class="s1">        or list of objects, or list of filenames, </span><span class="se">\</span>
<span class="s1">        or list of tuples storing filename/direction&#39;</span><span class="p">)</span>
    <span class="c1"># oct 2023, support input as a list</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Xin</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
        <span class="n">Xin</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">Xin</span><span class="p">]</span>
        <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">Xin</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">Xin</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">transforms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>    
    <span class="n">Xout</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="n">Xin</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transforms</span><span class="p">:</span>
        <span class="n">Xout</span> <span class="o">=</span> <span class="n">t</span><span class="p">(</span><span class="n">Xout</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Xout</span></div>
    
<div class="viewcode-block" id="apply_transform_float"><a class="viewcode-back" href="../emlddmm.html#emlddmm.apply_transform_float">[docs]</a><span class="k">def</span> <span class="nf">apply_transform_float</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Apply transform to image</span>
<span class="sd">    Image points stored in x, data stored in I</span>
<span class="sd">    transform stored in Xout</span>
<span class="sd">    </span>
<span class="sd">    There is an issue with numpy integer arrays, I&#39;ll have two functions</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">Xout</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">Xout</span><span class="o">.</span><span class="n">device</span><span class="p">),</span><span class="n">Xout</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">isnumpy</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">AphiI</span></div>

<div class="viewcode-block" id="apply_transform_int"><a class="viewcode-back" href="../emlddmm.html#emlddmm.apply_transform_int">[docs]</a><span class="k">def</span> <span class="nf">apply_transform_int</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">,</span><span class="n">double</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Apply transform to image</span>
<span class="sd">    Image points stored in x, data stored in I</span>
<span class="sd">    transform stored in Xout</span>
<span class="sd">    </span>
<span class="sd">    There is an issue with numpy integer arrays, I&#39;ll have two functions</span>
<span class="sd">    </span>
<span class="sd">    Note that we often require double precision when converting to floats and back</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is not &#39;nearest&#39; for ints.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">isnumpy</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">Itype</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="s1">&#39;mode&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nearest&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;nearest&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;mode must be nearest for ints&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="n">Xout</span><span class="o">.</span><span class="n">device</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span>
    
    <span class="c1"># for int, I need to convert to float for interpolation    </span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">double</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">Xout</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span><span class="n">Xout</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">),</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">Xout</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">isnumpy</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">Itype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">AphiI</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">AphiI</span></div>
    
            

        
<div class="viewcode-block" id="rigid2D"><a class="viewcode-back" href="../emlddmm.html#emlddmm.rigid2D">[docs]</a><span class="k">def</span> <span class="nf">rigid2D</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Rigid transformation between 2D slices.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">pass</span></div>
        
    
<div class="viewcode-block" id="write_outputs_for_pair"><a class="viewcode-back" href="../emlddmm.html#emlddmm.write_outputs_for_pair">[docs]</a><span class="k">def</span> <span class="nf">write_outputs_for_pair</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">outputs</span><span class="p">,</span>
                           <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">WJ</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">atlas_space_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">target_space_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">atlas_image_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">target_image_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># TODO: daniel double check this after bryson name changes (remove input)</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write outputs in standard format for a pair of images</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    output_dir : str</span>
<span class="sd">        Location to store output data.</span>
<span class="sd">    outputs : dict</span>
<span class="sd">        Dictionary of outputs from the emlddmm python code</span>
<span class="sd">    xI : list of numpy array</span>
<span class="sd">        Location of voxels in atlas</span>
<span class="sd">    I : numpy array</span>
<span class="sd">        Atlas image</span>
<span class="sd">    xJ : list of numpy array</span>
<span class="sd">        Location of voxels in target</span>
<span class="sd">    J : numpy array</span>
<span class="sd">        Target image</span>
<span class="sd">    atlas_space_name : str</span>
<span class="sd">        Name of atlas space (default &#39;atlas&#39;)</span>
<span class="sd">    target_space_name : str</span>
<span class="sd">        Name of target space (default &#39;target&#39;)</span>
<span class="sd">    atlas_image_name : str</span>
<span class="sd">        Name of atlas image (default &#39;atlasimage&#39;)</span>
<span class="sd">    target_image_name : str</span>
<span class="sd">        Name of target image (default &#39;targetimage&#39;)</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">    TODO</span>
<span class="sd">    ----</span>
<span class="sd">    Implement QC figures.</span>
<span class="sd">    </span>
<span class="sd">    Check device more carefully, probably better to put everything on cpu.</span>
<span class="sd">    </span>
<span class="sd">    Check dtype more carefully.</span>
<span class="sd">    </span>
<span class="sd">    Get determinant of jacobian. (done)</span>
<span class="sd">    </span>
<span class="sd">    Write velocity out and affine</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>    
    <span class="k">if</span> <span class="n">atlas_space_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atlas_space_name</span> <span class="o">=</span> <span class="s1">&#39;atlas&#39;</span>
    <span class="k">if</span> <span class="n">target_space_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_space_name</span> <span class="o">=</span> <span class="s1">&#39;target&#39;</span>
    <span class="k">if</span> <span class="n">atlas_image_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">atlas_image_name</span> <span class="o">=</span> <span class="s1">&#39;atlasimage&#39;</span>
    <span class="k">if</span> <span class="n">target_image_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">target_image_name</span> <span class="o">=</span> <span class="s1">&#39;targetimage&#39;</span>
           
        
    <span class="k">if</span> <span class="s1">&#39;A2d&#39;</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
        <span class="n">slice_matching</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slice_matching</span> <span class="o">=</span> <span class="kc">False</span>
        
    <span class="c1"># we will make everything float and cpu</span>
    <span class="n">device</span> <span class="o">=</span> <span class="s1">&#39;cpu&#39;</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">WJ</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">WJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">WJ</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span>
        
    <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span>
    <span class="n">IMAGES</span> <span class="o">=</span> <span class="s1">&#39;images&#39;</span> <span class="c1"># define some strings</span>
    <span class="n">TRANSFORMS</span> <span class="o">=</span> <span class="s1">&#39;transforms&#39;</span>
    <span class="c1"># make the output directory</span>
    <span class="c1"># note this function will do it recursively even if it exists</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># to atlas space</span>
    <span class="n">to_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
    <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># to atlas space from atlas space </span>
    <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
    <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># to atlas space from atlas space</span>
    <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
    <span class="c1"># write out the atlas (in single)</span>
    <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
               <span class="n">xI</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span><span class="s1">&#39;atlas&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">slice_matching</span><span class="p">:</span>        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing NOT slice matching outputs&#39;</span><span class="p">)</span>
        <span class="c1"># to atlas space from target space    </span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to atlas space from target space transforms    </span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># need atlas to target displacement</span>
        <span class="c1"># this is A phi - x</span>
        <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">],</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)))</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">phiXI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]],</span><span class="n">phi</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">-</span><span class="n">XV</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">XI</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span> <span class="o">+</span> <span class="n">XI</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">AphiXI</span> <span class="o">=</span> <span class="p">((</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@phiXI</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>    
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span><span class="n">xI</span><span class="p">,(</span><span class="n">AphiXI</span><span class="o">-</span><span class="n">XI</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement&#39;</span><span class="p">)</span>
        <span class="c1"># now detjac        </span>
        <span class="n">dxI</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>         
        <span class="n">detjac</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">AphiXI</span><span class="p">,</span><span class="n">spacing</span><span class="o">=</span><span class="n">dxI</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_detjac.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xI</span><span class="p">,</span><span class="n">detjac</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_detjac&#39;</span><span class="p">)</span>
        <span class="c1"># now we need the target to atlas image</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># this is generated form the target with AphiXI (make sure on same device, cpu)</span>
        <span class="n">phiiAiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">AphiXI</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xI</span><span class="p">,</span><span class="n">phiiAiJ</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># qc? TODO</span>
        
        <span class="c1"># now to target space</span>
        <span class="n">to_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># from target space (i.e identity)</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># target image</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># write out the target (in single)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xJ</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="s1">&#39;atlas&#39;</span><span class="p">)</span>
        <span class="c1"># now from atlas space</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to target space from atlas space transforms        </span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>
        <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phii</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phii</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">AiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phiiAiXJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">]],(</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">AiXJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">())</span> <span class="o">+</span> <span class="n">AiXJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span><span class="n">xJ</span><span class="p">,(</span><span class="n">phiiAiXJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">-</span><span class="n">XJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">())[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement&#39;</span><span class="p">)</span>
        <span class="n">dxJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">]</span> 
        <span class="n">detjac</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">phiiAiXJ</span><span class="p">,</span><span class="n">spacing</span><span class="o">=</span><span class="n">dxI</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_detjac.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xJ</span><span class="p">,</span><span class="n">detjac</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_detjac&#39;</span><span class="p">)</span>
        <span class="c1"># write out velocity field</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;velocity.vtk&#39;</span><span class="p">),</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_velocity&#39;</span><span class="p">)</span>
        <span class="c1"># write out affine</span>
        <span class="n">write_matrix_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;A.txt&#39;</span><span class="p">),</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="c1"># atlas image</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">phiiAiXJ</span><span class="o">.</span><span class="n">cpu</span><span class="p">(),</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xJ</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># TODO qc   </span>
        
    <span class="k">else</span><span class="p">:</span> <span class="c1"># if slice matching</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing slice matching transform outputs&#39;</span><span class="p">)</span>
        <span class="c1"># WORKING HERE TO MAKE SURE I HAVE THE RIGHT OUTPUTS</span>
        <span class="c1"># NOTE: in registered space we may need to sample in a different spot if origin is not in the middle</span>


        <span class="c1"># to atlas space from registered target space</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span> <span class="o">+</span> <span class="s1">&#39;_registered&#39;</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to atlas space from registered target space transforms    </span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># we need the atlas to registered displacement</span>
        <span class="c1"># this is  A phi - x</span>
        <span class="n">XV</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">torch</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">],</span><span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,)))</span>
        <span class="n">XI</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">phiXI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">phi</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">XI</span><span class="p">)</span> <span class="o">+</span> <span class="n">XI</span>            
        <span class="n">AphiXI</span> <span class="o">=</span> <span class="p">((</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@phiXI</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">][:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>                
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span><span class="n">xI</span><span class="p">,(</span><span class="n">AphiXI</span><span class="o">-</span><span class="n">XI</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement&#39;</span><span class="p">)</span>
        
        <span class="c1"># to atlas space from registered space images</span>
        <span class="c1"># nothing here because no images were acquired in this space</span>
        
        
        
        <span class="c1"># to atlas space from input target space</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to atlas space from input target space transforms    </span>
        <span class="c1"># THESE TRANSFORMS DO NOT EXIST</span>
        <span class="c1"># to atlas space from input target space images</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># to get these images I first need to map them to registered</span>
        <span class="n">XJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phi</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>        
        <span class="n">R</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
        <span class="c1"># TODO: implement a mean shift</span>
        <span class="n">meanshift</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">R</span><span class="p">[:,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">XJshift</span> <span class="o">=</span> <span class="n">XJ</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">XJshift</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-=</span> <span class="n">meanshift</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
        
        <span class="n">xJshift</span> <span class="o">=</span> <span class="p">[</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">meanshift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">xJ</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">meanshift</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># add mean shift below ( I added but didn&#39;t change names)</span>
        <span class="n">RXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span><span class="p">(</span><span class="n">XJshift</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">RXJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">XJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">],</span><span class="n">RXJ</span><span class="p">))</span>
        <span class="n">RiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">RXJ</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">phiiAiRiJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">RXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJshift</span><span class="p">],</span><span class="n">RiJ</span><span class="p">,</span><span class="n">AphiXI</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                   <span class="n">xI</span><span class="p">,</span><span class="n">phiiAiRiJ</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># qc in atlas space</span>
        <span class="n">qc_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="s1">&#39;qc&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>        
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">phiiAiRiJ</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;phiiAiRiJ&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;I&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    
        <span class="c1"># now we do to registered space</span>
        <span class="c1"># TODO: implement proper registered space sample points</span>
        <span class="c1"># note that I&#39;m applying transformations to XJ, but I should apply them to XJ with the mean shift</span>
        <span class="c1"># </span>
        
        
        <span class="n">to_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span> <span class="o">+</span> <span class="s1">&#39;_registered&#39;</span>
        <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># from input</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># transforms, registered to input</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1">#for i in range(R.shape[0]):</span>
        <span class="c1">#    # convert to xyz</span>
        <span class="c1">#    Rxyz = torch.tensor(R[i])</span>
        <span class="c1">#    Rxyz[:2] = torch.flip(Rxyz[:2],dims=(0,))</span>
        <span class="c1">#    Rxyz[:,:2] = torch.flip(Rxyz[:,:2],dims=(1,))</span>
        <span class="c1">#    # write out</span>
        <span class="c1">#    with open(os.path.join(from_space_dir)):</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJshift</span><span class="p">,(</span><span class="n">RXJ</span><span class="o">-</span><span class="n">XJshift</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># images</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJshift</span><span class="p">,(</span><span class="n">RiJ</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># from atlas</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># transforms, registered to atlas</span>
        <span class="n">phii</span> <span class="o">=</span> <span class="n">v_to_phii</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">AiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJshift</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phiiAiXJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">AiXJ</span><span class="p">)</span> <span class="o">+</span> <span class="n">AiXJ</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJshift</span><span class="p">,(</span><span class="n">phiiAiXJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># images</span>
        <span class="n">AphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phiiAiXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phiiAiXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">phiiAiXJ</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJshift</span><span class="p">,(</span><span class="n">AphiI</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># a qc directory</span>
        <span class="n">qc_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="s1">&#39;qc&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">RiJ</span><span class="p">,</span><span class="n">xJshift</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;RiJ&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span>
                                 <span class="sa">f</span><span class="s1">&#39;input_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_registered_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">AphiI</span><span class="p">,</span><span class="n">xJshift</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;AphiI&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span>
                                 <span class="sa">f</span><span class="s1">&#39;input_</span><span class="si">{</span><span class="n">atlas_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_registered_</span><span class="si">{</span><span class="n">target_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        
        <span class="c1"># to input space</span>
        <span class="n">to_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span>
        <span class="n">to_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># input to input</span>
        <span class="c1"># TODO: i can write the original images here</span>
        
        <span class="c1"># registered to input</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">target_space_name</span> <span class="o">+</span> <span class="s1">&#39;_registered&#39;</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># images, NONE        </span>
        <span class="c1"># transforms</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">Ri</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">])</span>
        <span class="n">RiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">R</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="o">@</span><span class="p">(</span><span class="n">XJ</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">]))[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ri</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">RiXJ</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">((</span><span class="n">XJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">],</span><span class="n">RiXJ</span><span class="p">))</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">RXJ</span><span class="o">-</span><span class="n">XJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        
        <span class="c1"># atlas to input</span>
        <span class="n">from_space_name</span> <span class="o">=</span> <span class="n">atlas_space_name</span>
        <span class="n">from_space_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="c1"># transforms</span>
        <span class="n">transforms_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">TRANSFORMS</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">AiRiXJ</span> <span class="o">=</span> <span class="p">((</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@RiXJ</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">phiiAiRiXJ</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">outputs</span><span class="p">[</span><span class="s1">&#39;xv&#39;</span><span class="p">],</span><span class="n">phii</span><span class="o">-</span><span class="n">XV</span><span class="p">,</span><span class="n">AiRiXJ</span><span class="p">)</span> <span class="o">+</span> <span class="n">AiRiXJ</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transforms_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_displacement.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">phiiAiRiXJ</span><span class="o">-</span><span class="n">XJ</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># images</span>
        <span class="n">images_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">from_space_dir</span><span class="p">,</span><span class="n">IMAGES</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        <span class="n">RAphiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="n">phiiAiRiXJ</span><span class="o">.</span><span class="n">device</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">phiiAiRiXJ</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span><span class="n">phiiAiRiXJ</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">images_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">),</span>
                  <span class="n">xJ</span><span class="p">,(</span><span class="n">RAphiI</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        
        <span class="c1"># input space qc        </span>
        <span class="n">qc_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">to_space_dir</span><span class="p">,</span><span class="s1">&#39;qc&#39;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="n">exist_ok</span><span class="p">)</span>
        
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">target_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">RAphiI</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;RAphiI&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">qc_dir</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">atlas_image_name</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.jpg&#39;</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>
        <span class="c1"># TODO: double check this is done</span>
        
<div class="viewcode-block" id="pad"><a class="viewcode-back" href="../emlddmm.html#emlddmm.pad">[docs]</a><span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Pad an image and its domain.    </span>
<span class="sd">    </span>
<span class="sd">    Perhaps include here</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xI : list of arrays</span>
<span class="sd">        Location of pixels in I</span>
<span class="sd">    I : array</span>
<span class="sd">        Image</span>
<span class="sd">    n : list of ints or list of pairs of ints</span>
<span class="sd">        Pad on front and back</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Not Implemented&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;only implemented for numpy&#39;</span><span class="p">)</span>
    
    <span class="k">pass</span></div>
    
<div class="viewcode-block" id="map_image"><a class="viewcode-back" href="../emlddmm.html#emlddmm.map_image">[docs]</a><span class="k">def</span> <span class="nf">map_image</span><span class="p">(</span><span class="n">emlddmm_path</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">,</span> <span class="n">from_space_name</span><span class="p">,</span> <span class="n">to_space_name</span><span class="p">,</span>
              <span class="n">input_image_fname</span><span class="p">,</span> <span class="n">output_image_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">from_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">use_detjac</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function will map imaging data from one space to another. </span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    There are four cases:</span>
<span class="sd">    </span>
<span class="sd">    #. 3D to 3D mapping: A single displacement field is used to map data</span>
<span class="sd">    </span>
<span class="sd">    #. 3D to 2D mapping: A single displacement field is used to map data, a slice filename is needed in addition to a space</span>
<span class="sd">    </span>
<span class="sd">    #. 2D to 2D mapping: A single matrix is used to map data.</span>
<span class="sd">    </span>
<span class="sd">    #. 2D to 3D mapping: Currently not supported. Ideally this will output data, and weights for a single slice, so it can be averaged with other slices.</span>
<span class="sd">    </span>
<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    This function was built for a particular use case at Cold Spring Harbor, and is generally not used.  </span>
<span class="sd">    It may be removed in the future.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emlddmm_path : str</span>
<span class="sd">        Path to the emlddmm python library, used for io</span>
<span class="sd">    root_dir : str</span>
<span class="sd">        The root directory of the output structure</span>
<span class="sd">    from_space_name : str</span>
<span class="sd">        The name of the space we are mapping data from</span>
<span class="sd">    to_space_name : str</span>
<span class="sd">        The name of the space we are mapping data to</span>
<span class="sd">    input_image_fname : str</span>
<span class="sd">        Filename of the input image to be transformed</span>
<span class="sd">    output_image_fname : str</span>
<span class="sd">        Filename of the output image after transformation. If None (default), it will be returned as a python variable but not written to disk.</span>
<span class="sd">    from_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    to_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    use_detjac : bool</span>
<span class="sd">        If the image represents a density, it should be transformed and multiplied by the Jacobian of the transformation</span>
<span class="sd">    </span>
<span class="sd">    Keyword Arguments</span>
<span class="sd">    -----------------</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Arguments passed to torch interpolation (grid_resample), e.g. padding_mode,</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phiI : array</span>
<span class="sd">        Transformed image</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If use_detjac set to True for 3D to 2D mapping. Detjac not currently supported for 3D to 2D.</span>
<span class="sd">    Exception</span>
<span class="sd">        2D to 3D not implemented yet, may not get implemented.</span>
<span class="sd">    Exception</span>
<span class="sd">        Jacobian not implemented yet for 2D slices.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    DetJac is ignored if mapping is 2D to 2D.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">split</span><span class="p">,</span><span class="n">join</span><span class="p">,</span><span class="n">splitext</span>
    <span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>     
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This function is experimental&#39;</span><span class="p">)</span>
    
    <span class="c1"># first load the image to be transformed</span>
    <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)</span>    
    
    <span class="c1"># find the transformation we need, in each case I will load the appropriate data, and return a phi</span>
    <span class="n">transform_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 1, 3D to 3D</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span><span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">))</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">detjac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 2, 3D to 2D</span>
        <span class="c1"># we have a displacement field  </span>
        <span class="n">to_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">to_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">))</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>        
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Detjac not currently supported for 3D to 2D&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1"># This is case 3, 2D to 2D, we have an xyz matrix        </span>
        <span class="n">to_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">from_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">to_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">from_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_matrix.txt&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DetJac is 1 for 2D to 2D, so it is ignored&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;matrix data:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># we need to convert this to a displacement field</span>
        <span class="c1"># to do this we need some image to get sample points</span>
        <span class="c1"># we use the &quot;to&quot; slice image name</span>
        <span class="n">image_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span><span class="n">to_space_name</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span><span class="p">,</span><span class="s1">&#39;images&#39;</span><span class="p">)</span>
        
        <span class="n">testfile</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">image_dir</span><span class="p">,</span><span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;*_to_*&#39;</span> <span class="o">+</span> <span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;*.vtk&#39;</span><span class="p">))</span>
        <span class="n">xS</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">_</span><span class="p">,</span><span class="n">_</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">testfile</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xS</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="c1"># now we can build a phi</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">data</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="p">((</span><span class="n">A</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@Xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Xs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="kc">None</span><span class="p">],</span><span class="n">phi</span><span class="p">)</span> <span class="p">)</span>         
        <span class="n">xD</span> <span class="o">=</span> <span class="n">xS</span>
        
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># this is 2D to 3D we have a displacement field</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D to 3D not implemented yet, may not get implemented&#39;</span><span class="p">)</span>
    
    <span class="c1"># apply the transform to the image</span>
    <span class="c1"># if desired calculate jacobian</span>
    <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Jacobian not implemented yet for 2D slices&#39;</span><span class="p">)</span>
        
    <span class="c1"># todo, implement when I is int</span>
    <span class="n">phiI</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>    
    
    <span class="k">if</span> <span class="n">output_image_directory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># we need to go back to the four cases here</span>
        <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 1, 3d to 3d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_image_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            <span class="n">outtitle</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">outfname</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 2, 3d to 2d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_image_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            <span class="n">outtitle</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">outfname</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 3, 2d to 2d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_image_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_image_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            <span class="n">outtitle</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">outfname</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>            
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case 4, 2d to 3d</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;2D to 3D not supported&#39;</span><span class="p">)</span>
            
        <span class="c1"># a hack for slice thickness</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">20.0</span><span class="p">])</span>    
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing file with name </span><span class="si">{</span><span class="n">outfname</span><span class="si">}</span><span class="s1"> and title </span><span class="si">{</span><span class="n">outtitle</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">outfname</span><span class="p">,</span><span class="n">xD</span><span class="p">,</span><span class="n">phiI</span><span class="p">,</span><span class="n">outtitle</span><span class="p">)</span>
        
        
    <span class="k">return</span> <span class="n">xD</span><span class="p">,</span><span class="n">phiI</span></div>
    
    
        
<div class="viewcode-block" id="map_points"><a class="viewcode-back" href="../emlddmm.html#emlddmm.map_points">[docs]</a><span class="k">def</span> <span class="nf">map_points</span><span class="p">(</span><span class="n">emlddmm_path</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">,</span> <span class="n">from_space_name</span><span class="p">,</span> <span class="n">to_space_name</span><span class="p">,</span>
              <span class="n">input_points_fname</span><span class="p">,</span> <span class="n">output_points_directory</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">from_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_slice_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">use_detjac</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;    </span>
<span class="sd">    For points we need to get the transforms in the opposite folder to images.</span>
<span class="sd">    </span>
<span class="sd">    This function will map imaging data from one space to another. </span>
<span class="sd">    There are four cases:</span>
<span class="sd">    </span>
<span class="sd">    #. 3D to 3D mapping: A single displacement field is used to map data</span>
<span class="sd">    </span>
<span class="sd">    #. 3D to 2D mapping: Currently not supported.</span>
<span class="sd">    </span>
<span class="sd">    #. 2D to 2D mapping: A single matrix is used to map data.</span>
<span class="sd">    </span>
<span class="sd">    #. 2D to 3D mapping: A single displacement field is used to map data, a slice filename is needed in addition to a space</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    This function was built for a particular use case at Cold Spring Harbor, and is generally not used.  </span>
<span class="sd">    It may be removed in the future.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    emlddmm_path : str</span>
<span class="sd">        Path to the emlddmm python library, used for io</span>
<span class="sd">    root_dir : str</span>
<span class="sd">        The root directory of the output structure</span>
<span class="sd">    from_space_name : str</span>
<span class="sd">        The name of the space we are mapping data from</span>
<span class="sd">    to_space_name : str</span>
<span class="sd">        The name of the space we are mapping data to</span>
<span class="sd">    input_points_fname : str</span>
<span class="sd">        Filename of the input image to be transformed</span>
<span class="sd">    output_directory_fname : str</span>
<span class="sd">        Filename of the output image after transformation. If None (default), it will be returned as a python variable but not written to disk.</span>
<span class="sd">    from_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    to_slice_name : str</span>
<span class="sd">        When transforming slice based image data only, we also need to know the filename of the slice the data came from.</span>
<span class="sd">    use_detjac : bool</span>
<span class="sd">        If the image represents a density, it should be transformed and multiplied by the Jacobian of the transformation</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Arguments passed to torch interpolation (grid_resample), e.g. padding_mode,</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    phiP : array</span>
<span class="sd">        Transformed points</span>
<span class="sd">    connectivity : list of lists</span>
<span class="sd">        Same connectivity entries as loaded data</span>
<span class="sd">    connectivity_type : str</span>
<span class="sd">        Same connectivity type as loaded data</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        3D to 2D mapping is not implemented for points.</span>
<span class="sd">    Exception</span>
<span class="sd">        If use_detjac set to True for 2D to 3D mapping. Detjac not currently supported for 2D to 3D</span>
<span class="sd">    Exception</span>
<span class="sd">        If use_detjac set to True. Jacobian is not implemented yet.</span>
<span class="sd">    Exception</span>
<span class="sd">        If attempting to map points from 3D to 2D. </span>
<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    DetJac is ignored if mapping is 2D to 2D.    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">split</span><span class="p">,</span><span class="n">join</span><span class="p">,</span><span class="n">splitext</span>
    <span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>    
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;This function is experimental&#39;</span><span class="p">)</span>
    
    <span class="c1"># first load the points to be transformed</span>
    <span class="n">points</span><span class="p">,</span><span class="n">connectivity</span><span class="p">,</span><span class="n">connectivity_type</span><span class="p">,</span><span class="n">name</span> <span class="o">=</span> <span class="n">read_vtk_polydata</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)</span>    
    
    <span class="c1"># find the transformation we need, in each case I will load the appropriate data, and return a phi</span>
    <span class="c1"># note that for points we use the inverse to images</span>
    <span class="c1"># transform_dir = join(root_dir,to_space_name,from_space_name + &#39;_to_&#39; + to_space_name,&#39;transforms&#39;)</span>
    <span class="c1"># above was for images</span>
    <span class="n">transform_dir</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span><span class="n">from_space_name</span><span class="p">,</span><span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">from_space_name</span><span class="p">,</span><span class="s1">&#39;transforms&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 1, 3D to 3D</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span><span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">))</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">detjac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xD</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is case 2, 3D to 2D</span>
        <span class="c1"># this one is not implemented</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;3D to 2D not implemented for points&#39;</span><span class="p">)</span>
        
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1"># This is case 3, 2D to 2D, we have an xyz matrix        </span>
        <span class="n">to_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">from_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">file_search</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">from_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">to_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_matrix.txt&#39;</span><span class="p">)</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;DetJac is 1 for 2D to 2D, so it is ignored&#39;</span><span class="p">)</span>
            
        <span class="n">data</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;matrix data:&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># we do not need to convert this to a displacement field</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># this is 2D to 3D we have a displacement field</span>
        <span class="n">from_slice_name_</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">file_search</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">transform_dir</span><span class="p">,</span><span class="n">from_space_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">from_slice_name_</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">to_space_name</span> <span class="o">+</span> <span class="s1">&#39;_displacement.vtk&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
        <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="p">(</span><span class="n">file_search</span><span class="p">)</span>
        <span class="n">xD</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">files</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>        
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">D</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xD</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>        
        <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Detjac not currently supported for 2D to 3D&#39;</span><span class="p">)</span>
            
    
    <span class="c1"># apply the transform to the image</span>
    <span class="c1"># if desired calculate jacobian</span>
    <span class="k">if</span> <span class="n">use_detjac</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Jacobian not implemented yet&#39;</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">phi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># points is size N x 3</span>
        <span class="c1"># we want 3 x 1 x 1 x N</span>
        <span class="n">points_</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">transpose</span><span class="p">()[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span>                
        <span class="n">phiP</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xD</span><span class="p">,</span><span class="n">phi</span><span class="p">,</span><span class="n">points_</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phiP</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">phiP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="n">phiP</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    
    <span class="k">if</span> <span class="n">output_points_directory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>        
        <span class="c1"># we need to go back to the four cases here</span>
        <span class="k">if</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 1, 3d to 3d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_points_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 2, 3d to 2d</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;3D to 2D not supported&#39;</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">from_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">to_slice_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># case 3, 2d to 2d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_points_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">to_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
                    
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># case 4, 2d to 3d</span>
            <span class="n">outfname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">output_points_directory</span><span class="p">,</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">from_space_name</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">split</span><span class="p">(</span><span class="n">splitext</span><span class="p">(</span><span class="n">from_slice_name</span><span class="p">)[</span><span class="mi">0</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">splitext</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">input_points_fname</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">_to_</span><span class="si">{</span><span class="n">to_space_name</span><span class="si">}</span><span class="s1">.vtk&#39;</span><span class="p">)</span>
            
            
         
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;writing file with name </span><span class="si">{</span><span class="n">outfname</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">write_vtk_polydata</span><span class="p">(</span><span class="n">outfname</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">phiP</span><span class="p">,</span><span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">,</span><span class="n">connectivity_type</span><span class="o">=</span><span class="n">connectivity_type</span><span class="p">)</span>
        
        
    <span class="k">return</span> <span class="n">phiP</span><span class="p">,</span> <span class="n">connectivity</span><span class="p">,</span> <span class="n">connectivity_type</span><span class="p">,</span> <span class="n">name</span></div>
    



<div class="viewcode-block" id="convert_points_from_json"><a class="viewcode-back" href="../emlddmm.html#emlddmm.convert_points_from_json">[docs]</a><span class="k">def</span> <span class="nf">convert_points_from_json</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">d_high</span><span class="p">,</span> <span class="n">n_high</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sidecar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    We load points from a json produced by Samik at cold spring harbor.</span>
<span class="sd">    </span>
<span class="sd">    These are indexed to pixels in a high res image, rather than any physical units.</span>
<span class="sd">    </span>
<span class="sd">    To convert to proper points in 3D for transforming, we need information about pixel size and origin.</span>
<span class="sd">    </span>
<span class="sd">    Pixel size of the high res image is a required input.</span>
<span class="sd">    </span>
<span class="sd">    If we have a json sidecar file that was prepared for the registration dataset, we can get all the info from this.</span>
<span class="sd">    </span>
<span class="sd">    If not, we get it elsewhere.</span>
<span class="sd">    </span>
<span class="sd">    Origin information can be determined from knowing the number of pixels in the high res image. </span>
<span class="sd">    </span>
<span class="sd">    Z coordinate information is not required if we are only applying 2D transforms, </span>
<span class="sd">    but for 3D it will have to be input manually if we do not have a sidecar file.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : str or numpy array</span>
<span class="sd">        either a geojson filename, or a Nx2 numpy array with coordinates loaded from such a file.</span>
<span class="sd">    d_high : float</span>
<span class="sd">        pixel size of high resolution image where cells were detected</span>
<span class="sd">    n_high : str or numpy array</span>
<span class="sd">        WIDTH x HEIGHT of high res image.  Or the filename of the high res image.</span>
<span class="sd">    sidecar : str</span>
<span class="sd">        Filename of sidecar file to get z and origin info</span>
<span class="sd">    z : float</span>
<span class="sd">        z coordinate</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : numpy array</span>
<span class="sd">        A Nx3 array of points in physical units using our coordinate system convention (origin in center).</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If we are applying 3D transforms, we need a z coordinate.  This can be determined either by specifying it</span>
<span class="sd">    or by using a sidecar file.  If we have neither, it ill be set to 0.</span>
<span class="sd">    </span>
<span class="sd">    TODO</span>
<span class="sd">    ----</span>
<span class="sd">    Consider setting z to nan instead of zero.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c1"># deal with the input points</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;points was a string, loading from json file&#39;</span><span class="p">)</span>
        <span class="c1"># If we specified a string, load the points</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">points</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span> <span class="k">if</span> <span class="n">p</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Points was not a string, using as is&#39;</span><span class="p">)</span>
    
    <span class="c1"># start processing points</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">[:,::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># flip the sign of the x0 component</span>
    <span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># multiply by the pixel size</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="n">d_high</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;flipped the first and second column, multiplied the first column of the result by -1&#39;</span><span class="p">)</span>
    
    <span class="c1"># now check if there is a sidecar</span>
    <span class="k">if</span> <span class="n">sidecar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sidecar specified, loading origin and z information&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">sidecar</span><span class="p">,</span><span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> 
        <span class="c1"># I don&#39;t think this is quite right</span>
        <span class="c1"># this would be right if the downsampling factor was 1 and the voxel centers matched</span>
        <span class="c1"># if the downsampling factor was 2, we&#39;d have to move a quarter (big) voxel to the left</span>
        <span class="c1"># | o | _ |</span>
        <span class="c1"># if the downsampling factor was 4 we&#39;d have to move 3 eights</span>
        <span class="c1"># | o | _ | _ | _ |</span>
        <span class="c1"># what&#39;s the pattern? we move half a big voxel to the left, then half a small voxel to the right</span>
        <span class="c1"># </span>
        <span class="c1">#downsampling_factor = (np.diag(np.array(data[&#39;SpaceDirections&#39;][1:]))/(d_high))[0]</span>
        <span class="n">d_low</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SpaceDirections&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;d low </span><span class="si">{</span><span class="n">d_low</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SpaceOrigin&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_low</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">d_high</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SpaceOrigin&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">d_low</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">d_high</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;SpaceOrigin&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span>   <span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no sidecar specified, loading origin from n_high&#39;</span><span class="p">)</span>
        <span class="c1"># we have to get origin and z information elsewhere</span>
        <span class="k">if</span> <span class="n">n_high</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;If not specifying sidecar, you must specify n_high&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_high</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;loading n_high from jp2 file&#39;</span><span class="p">)</span>
            <span class="c1"># this sould be a jp2 file</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">n_high</span><span class="p">)</span>
            <span class="n">n_high</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="c1"># this should be xy</span>
            <span class="n">image</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># in this case, the point 0,0 (first pixel) should have a coordinate -n/2            </span>
        <span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">n_high</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">d_high</span>
        <span class="n">q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">n_high</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">d_high</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;added origin&#39;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">z</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if we have no z information we will just pad zeros</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;no z coordinate, appending 0&#39;</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">q</span>   <span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;appending input z coordinate&#39;</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">q</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="p">,</span><span class="n">q</span>   <span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            
        
    <span class="k">return</span> <span class="n">q</span></div>
        

<div class="viewcode-block" id="apply_transform_from_file_to_points"><a class="viewcode-back" href="../emlddmm.html#emlddmm.apply_transform_from_file_to_points">[docs]</a><span class="k">def</span> <span class="nf">apply_transform_from_file_to_points</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">tform_file</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    To transform points from spacei to spacej (example from fluoro to nissl_registerd)</span>
<span class="sd">    We look for the output folder called</span>
<span class="sd">    outputs/spacei/spacej_to_spacei/transforms (example outputs/fluoro/nissl_registered_to_fluoro/transforms)</span>
<span class="sd">    Note &quot;spacej to spacei&quot; is not a typo </span>
<span class="sd">    (even though it looks backwards, point data uses inverse of transform as compared to images).</span>
<span class="sd">    In the transforms folder, there are transforms of the form</span>
<span class="sd">    &quot;spacei to spacej&quot;.  </span>
<span class="sd">    If applying transforms to slice data, you will have to find the appropriate slice.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    q : numpy array</span>
<span class="sd">        A Nx3 numpy array of coordinates in slice,row,col order</span>
<span class="sd">    tform_file : str</span>
<span class="sd">        A string pointing to a transform file</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -----</span>
<span class="sd">    Tq : numpy array</span>
<span class="sd">        The transformed set of points.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">tform_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.txt&#39;</span><span class="p">):</span>
        <span class="c1"># this is a matrix</span>
        <span class="c1"># we do matrix multiplication to the xy components, and leave the z component unchanged</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">read_matrix_data</span><span class="p">(</span><span class="n">tform_file</span><span class="p">)</span>                
        <span class="n">Tq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">Tq</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:</span><span class="mi">2</span><span class="p">]</span><span class="nd">@q</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">R</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Tq</span>
    <span class="k">elif</span> <span class="n">tform_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;displacement.vtk&#39;</span><span class="p">):</span>
        <span class="c1"># this is a vtk displacement field</span>
        <span class="n">x</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">tform_file</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">identity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">identity</span> <span class="c1"># add identity to convert &quot;displacement&quot; to &quot;position&quot;</span>
        <span class="c1"># evaluate the position field at the location of these points.</span>
        <span class="n">Tq</span> <span class="o">=</span> <span class="n">interpn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">phi</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tq</span></div>
    


<div class="viewcode-block" id="orientation_to_RAS"><a class="viewcode-back" href="../emlddmm.html#emlddmm.orientation_to_RAS">[docs]</a><span class="k">def</span> <span class="nf">orientation_to_RAS</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Compute a linear transform from a given orientation to RAS.</span>
<span class="sd">    </span>
<span class="sd">    Orientations are specified using 3 letters, by selecting one of each </span>
<span class="sd">    pair for each image axis: R/L, A/P, S/I</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orientation : 3-tuple</span>
<span class="sd">        orientation can be any iterable with 3 components. </span>
<span class="sd">        Each component should be one of R/L, A/P, S/I. There should be no duplicates</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ao : 3x3 numpy array</span>
<span class="sd">        A linear transformation to transform your image to RAS        </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">orientation_</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">orientation</span><span class="p">]</span>
    <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># first step, flip if necessary, so we only use symbols R A and S</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">orientation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
            <span class="n">Ao</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">orientation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;R&#39;</span>
        <span class="k">if</span> <span class="n">orientation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;P&#39;</span><span class="p">:</span>
            <span class="n">Ao</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">orientation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
        <span class="k">if</span> <span class="n">orientation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
            <span class="n">Ao</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">orientation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;S&#39;</span>

    <span class="c1"># now we need to handle permutations</span>
    <span class="c1"># there are 6 cases</span>
    <span class="k">if</span> <span class="n">orientation_</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">]:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">orientation_</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">]:</span>
        <span class="c1"># flip the last two axes to change to RAS</span>
        <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="nd">@Ao</span> <span class="c1"># elementary matrix is identity with rows flipped</span>
        <span class="n">orientation_</span> <span class="o">=</span> <span class="p">[</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="n">orientation_</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">]:</span>
        <span class="c1"># flip the first two axes</span>
        <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span><span class="nd">@Ao</span> 
        <span class="n">orientation_</span> <span class="o">=</span> <span class="p">[</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="n">orientation_</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;R&#39;</span><span class="p">]:</span>
        <span class="c1"># we need a 2,0,1 permutation</span>
        <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="nd">@np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="nd">@Ao</span> 
        <span class="n">orientation_</span> <span class="o">=</span> <span class="p">[</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="n">orientation_</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;R&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">]:</span>
        <span class="c1"># flip the first two, then the second two</span>
        <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="nd">@np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span><span class="nd">@Ao</span> 
        <span class="n">orientation_</span> <span class="o">=</span> <span class="p">[</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>        
    <span class="k">elif</span> <span class="n">orientation_</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">,</span><span class="s1">&#39;A&#39;</span><span class="p">,</span><span class="s1">&#39;R&#39;</span><span class="p">]:</span>
        <span class="c1"># flip the first and last</span>
        <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span><span class="nd">@Ao</span>         
        <span class="n">orientation_</span> <span class="o">=</span> <span class="p">[</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">orientation_</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Something is wrong with your orientation&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Ao</span></div>

<div class="viewcode-block" id="orientation_to_orientation"><a class="viewcode-back" href="../emlddmm.html#emlddmm.orientation_to_orientation">[docs]</a><span class="k">def</span> <span class="nf">orientation_to_orientation</span><span class="p">(</span><span class="n">orientation0</span><span class="p">,</span><span class="n">orientation1</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Compute a linear transform from one given orientation to another.</span>
<span class="sd">    </span>
<span class="sd">    Orientations are specified using 3 letters, by selecting one of each </span>
<span class="sd">    pair for each image axis: R/L, A/P, S/I</span>
<span class="sd">    </span>
<span class="sd">    This is done by computing transforms to and from RAS.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orientation : 3-tuple</span>
<span class="sd">        orientation can be any iterable with 3 components. </span>
<span class="sd">        Each component should be one of R/L, A/P, S/I. There should be no duplicates</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ao : 3x3 numpy array</span>
<span class="sd">        A linear transformation to transform your image from orientation0 to orientation1        </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">orientation_to_RAS</span><span class="p">(</span><span class="n">orientation1</span><span class="p">,</span><span class="n">verbose</span><span class="p">))</span><span class="nd">@orientation_to_RAS</span><span class="p">(</span><span class="n">orientation0</span><span class="p">,</span><span class="n">verbose</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Ao</span>    </div>
        
<div class="viewcode-block" id="affine_from_figure"><a class="viewcode-back" href="../emlddmm.html#emlddmm.affine_from_figure">[docs]</a><span class="k">def</span> <span class="nf">affine_from_figure</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">shift</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span><span class="n">angle</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Build small affine transforms by looking at figures generated in draw.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : str</span>
<span class="sd">        Two letters. &quot;t&quot;,&quot;m&quot;,&quot;b&quot; for top row middle row bottom row.</span>
<span class="sd">    </span>
<span class="sd">        Then &#39;w&#39;,&#39;e&#39;,&#39;n&#39;,&#39;s&#39; for left right up down</span>
<span class="sd">    </span>
<span class="sd">        Or &#39;r&#39;,&#39;l&#39; for turn right turn left</span>
<span class="sd">    </span>
<span class="sd">        or &#39;id&#39; for identity.</span>
<span class="sd">    shift : float</span>
<span class="sd">        How far to shift.</span>
<span class="sd">    angle : float</span>
<span class="sd">        How far to rotate (in degrees)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A0 : numpy array</span>
<span class="sd">        4x4 numpy array affine transform matrix</span>
<span class="sd">      </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    
    <span class="n">theta</span> <span class="o">=</span> <span class="n">angle</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]])</span>    
    <span class="n">A0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;ts&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;be&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;tn&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;bw&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;te&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;me&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;tw&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;mw&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;mn&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;bn&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">shift</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;ms&#39;</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;bs&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">shift</span>        
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;bl&#39;</span><span class="p">:</span>        
        <span class="n">A0</span><span class="p">[((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>  <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;br&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))]</span>  <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;ml&#39;</span><span class="p">:</span>        
        <span class="n">A0</span><span class="p">[((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span>  <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>    
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;mr&#39;</span><span class="p">:</span>        
        <span class="n">A0</span><span class="p">[((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span>  <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;tl&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span>  <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>    
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;tr&#39;</span><span class="p">:</span>
        <span class="n">A0</span><span class="p">[((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))]</span>  <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>    
    <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;id&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;input string not supported.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">A0</span></div>



<div class="viewcode-block" id="compute_atlas_from_slices"><a class="viewcode-back" href="../emlddmm.html#emlddmm.compute_atlas_from_slices">[docs]</a><span class="k">def</span> <span class="nf">compute_atlas_from_slices</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">ooop</span><span class="p">,</span><span class="n">niter</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">I</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; </span>
<span class="sd">    Construct an atlas image by averaging between slices.</span>
<span class="sd">    </span>
<span class="sd">    This uses an MM (also could be interpreted as EM) algorithm for </span>
<span class="sd">    converting a weighted least squares problem to an ordinary least squares problem.</span>
<span class="sd">    The latter can be solved as a stationary problem, and updated iteratively.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : array</span>
<span class="sd">        an C x slice x row x col image array.</span>
<span class="sd">    W : array</span>
<span class="sd">        An slice x row x col array of weights</span>
<span class="sd">    ooop : array</span>
<span class="sd">        a 1D array with &quot;slice&quot; elements.  This is a frequency domain</span>
<span class="sd">        one over operator for doing smoothing.</span>
<span class="sd">    niter : int</span>
<span class="sd">        Number of iterations to update in MM algorithm. (default to 10)</span>
<span class="sd">    I : array</span>
<span class="sd">        An C x slice x row x col image array representing an initial guess.</span>
<span class="sd">    draw : int</span>
<span class="sd">        Draw the image every draw iterations.  Do not draw if 0 (default).</span>
<span class="sd">    </span>
<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    This code uses numpy, not torch, since it is not gradient based.</span>
<span class="sd">        </span>
<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    Better boundary conditions</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">I</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">niter</span><span class="p">):</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">W</span><span class="o">*</span><span class="n">J</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">W</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">ooop</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="c1"># question, am I missing something? like divide by the weight?</span>
        <span class="c1"># like, what if the weight is 0.5 everywhere? This will not give the right answer</span>
        <span class="k">if</span> <span class="n">draw</span> <span class="ow">and</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">it</span><span class="o">%</span><span class="n">draw</span> <span class="ow">or</span> <span class="n">it</span> <span class="o">==</span> <span class="n">niter</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;it </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">I</span></div>
    
    
    
<div class="viewcode-block" id="atlas_free_reconstruction"><a class="viewcode-back" href="../emlddmm.html#emlddmm.atlas_free_reconstruction">[docs]</a><span class="k">def</span> <span class="nf">atlas_free_reconstruction</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39; Atlas free slice alignment</span>
<span class="sd">    </span>
<span class="sd">    Uses an MM algorithm to align slices.  Minimizes a Sobolev norm over rigid transformations of each slice.</span>
<span class="sd">    </span>
<span class="sd">    All arguments are keword arguments</span>
<span class="sd">    </span>
<span class="sd">    Keword Arguments</span>
<span class="sd">    ----------------</span>
<span class="sd">    xJ : list of arrays</span>
<span class="sd">        Lists of pixel locations in slice row col axes</span>
<span class="sd">    J : array</span>
<span class="sd">        A C x slice x row x col set of 2D image.</span>
<span class="sd">    W : array</span>
<span class="sd">        A slice x row x col set of weights of 2D images.  1 for good quality, to 0 for bad quality or out of bounds.</span>
<span class="sd">    a : float</span>
<span class="sd">        length scale (multiplied by laplacian) for smootheness averaging between slices. Defaults to twice the slice separation.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power of laplacian in somothing. Defaults to 2.    </span>
<span class="sd">    draw : int</span>
<span class="sd">        Draw figure (default false)</span>
<span class="sd">    n_steps : int      </span>
<span class="sd">        Number of iterations of MM algorithm.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        All other keword arguments are passed along to slice matching in the emlddmm algorithm.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dictionary</span>
<span class="sd">        All outputs from emlddmm algorithm, plus the new image I, and reconstructed image Jr</span>
<span class="sd">    out[&#39;I&#39;] : numpy array</span>
<span class="sd">        A C x slice x row x col set of 2D images (same size as J), averaged between slices.</span>
<span class="sd">    out[&#39;Jr&#39;] : numpy array</span>
<span class="sd">        A C x slice x row x col set of 2D images (same size as J)</span>
<span class="sd">        </span>
<span class="sd">    Todo</span>
<span class="sd">    ----</span>
<span class="sd">    Think about how to do this with some slices fixed.</span>
<span class="sd">    Think about normalizing slice to slice contrast.</span>
<span class="sd">        </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;J&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;J is a required keyword argument&#39;</span><span class="p">)</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="s1">&#39;xJ&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;xJ is a required keyword argument&#39;</span><span class="p">)</span>
    
    <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xJ&#39;</span><span class="p">)]</span>
    
    <span class="n">dJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">])</span>
    <span class="n">nJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="s1">&#39;W&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;W&#39;</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="s1">&#39;n_steps&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">n_steps</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_steps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;n_steps&#39;</span><span class="p">)</span>
    <span class="c1"># create smoothing operators</span>
    <span class="c1"># define an operator L, it can be a gaussian derivative or whatever</span>
    <span class="c1">#a = dJ[0]*2</span>
    <span class="k">if</span> <span class="s1">&#39;a&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>            
        <span class="n">a</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">))</span>    
    
    <span class="c1">#p = 2.0</span>
    <span class="k">if</span> <span class="s1">&#39;p&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mf">2.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">))</span>

    <span class="n">fJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="o">/</span><span class="n">d</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nJ</span><span class="p">,</span><span class="n">dJ</span><span class="p">)]</span>
    <span class="c1"># note this operator must have an identity in it to be a solution to our problem.</span>
    <span class="c1"># the scale is then set entirely by a</span>
    <span class="c1"># note it shouldn&#39;t really be identity, it should be sigma^2M.</span>
    <span class="c1"># but in our equations, we can just multiply everything through by 1/2/sigmaM**2</span>
    <span class="c1"># (1 + a^2 \Delta )^(2p) (here p = 2, \Delta is the discrete Laplacian) </span>
    
    <span class="k">if</span> <span class="s1">&#39;lddmm_operator&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">lddmm_operator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lddmm_operator&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lddmm_operator</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">lddmm_operator</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span> <span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">dJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">))</span> <span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="c1"># note there must be a 1+ here</span>
        <span class="c1">#op = 1.0 + ( 10*(1.0 + a**2/dJ[0]**2*(1.0 - np.cos(fJ[0]*dJ[0]*np.pi*2) )) )**(2.0*p) # note there must be a 1+ here</span>
        
        <span class="n">ooop</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">op</span>
        <span class="c1"># normalize</span>
        <span class="n">ooop</span> <span class="o">=</span> <span class="n">ooop</span><span class="o">/</span><span class="n">ooop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># we can use a different kernel in the space domain</span>
        <span class="c1"># here is the objective we solve</span>
        <span class="c1"># estimate R (rigid transforms) and I (atlas image)</span>
        <span class="c1"># |I|^2_{highpass} + |I - R J|^2_{L2}</span>
        <span class="c1"># where |I|^2_{highpass} = \int   |L I|^2 dx and L is a highpass operator</span>
        <span class="c1"># in the past I used power of laplacian for L</span>
        <span class="c1"># we could define L such that it&#39;s kernel is a power law (or a guassian or something without ripples)</span>
        <span class="c1"># </span>
        
        <span class="c1"># let&#39;s try this power law</span>
        <span class="n">op</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># jan 11, 2024, it does not decay fast enough, so try below</span>
        <span class="n">op</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">op</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mf">1.5</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">((</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">op</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>    <span class="c1"># this will build in the necessary symmetry</span>
        <span class="c1"># recall this is the low pass</span>
        <span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">op</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># now we have the highpass</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">op</span> <span class="o">/</span> <span class="n">op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ooop</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">op</span>
    
    
    
    <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fJ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ooop</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;spatial frequency&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;smoothing operator&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
        <span class="n">ooop_space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">ooop</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xJ</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ooop_space</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;space&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;smoothing operator space&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    
    <span class="c1"># set up config for registration</span>
    <span class="n">A2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">config</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;A2d&#39;</span><span class="p">:</span><span class="n">A2d</span><span class="p">,</span>
        <span class="s1">&#39;slice_matching&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
        <span class="s1">&#39;dv&#39;</span><span class="p">:</span><span class="mf">2000.0</span><span class="p">,</span> <span class="c1"># a big number to essentially disable it</span>
        <span class="s1">&#39;v_start&#39;</span><span class="p">:</span><span class="mi">100000</span><span class="p">,</span> <span class="c1"># disable it</span>
        <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="c1"># a small number</span>
        <span class="s1">&#39;ev&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># disable it</span>
        <span class="s1">&#39;eA&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="c1"># disable it</span>
        <span class="s1">&#39;eA2d&#39;</span><span class="p">:</span><span class="mf">2e2</span><span class="p">,</span> <span class="c1"># this worked reasonably well for my test data</span>
        <span class="s1">&#39;downI&#39;</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="c1"># extra downsampling for registration</span>
        <span class="s1">&#39;downJ&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
        <span class="s1">&#39;order&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># no contrast mapping</span>
        <span class="s1">&#39;full_outputs&#39;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span>
        <span class="s1">&#39;sigmaM&#39;</span><span class="p">:</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="s1">&#39;sigmaB&#39;</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span>
        <span class="s1">&#39;sigmaA&#39;</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">config</span><span class="p">[</span><span class="s1">&#39;n_draw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># don&#39;t draw</span>
    <span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="c1"># update with anything else</span>
    
    
    <span class="n">XJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xJ</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
    <span class="n">xJd</span><span class="p">,</span><span class="n">Jd</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">])</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">fig2</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>



    <span class="c1"># first estimate</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">J</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">J</span><span class="o">*</span><span class="n">W</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">),</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">compute_atlas_from_slices</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">ooop</span><span class="p">,</span><span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
        <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial atlas&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>    
    
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;starting it </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># map it</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">emlddmm</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span><span class="n">xI</span><span class="o">=</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="o">=</span><span class="n">xJ</span><span class="p">,</span><span class="n">W0</span><span class="o">=</span><span class="n">W</span><span class="p">,</span><span class="n">device</span><span class="o">=</span><span class="s1">&#39;cpu&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
        <span class="c1"># sometimes this gives an error</span>
        <span class="c1"># update Jr and Wr</span>

        <span class="n">tform</span> <span class="o">=</span> <span class="n">compose_sequence</span><span class="p">([</span><span class="n">Transform</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">])],</span><span class="n">XJ</span><span class="p">)</span>
        
        <span class="n">WM</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;WM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">WM</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xJd</span><span class="p">,</span><span class="n">WM</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span><span class="n">XJ</span><span class="p">)</span>
        <span class="n">Wr</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">WM</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>
        <span class="n">Wr</span> <span class="o">/=</span> <span class="n">Wr</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
        <span class="c1"># the approach on the next two lines really helped wiht artifacts near the border</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Jr = apply_transform_float(xJ,J*Wr,tform,padding_mode=&#39;border&#39;) # default padding is border</span>
<span class="sd">        Wr_ = apply_transform_float(xJ,Wr,tform,padding_mode=&#39;border&#39;)[0] # default padding is border</span>
<span class="sd">        Jr = Jr/(Wr_[None] + 1e-6)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="c1"># the alternative is this</span>
        <span class="n">Jr</span> <span class="o">=</span> <span class="n">apply_transform_float</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">tform</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)</span> <span class="c1"># default padding is border</span>
        <span class="c1"># but I don&#39;t think the final Wr is that good, so let&#39;s use this        </span>
        <span class="n">Wr</span> <span class="o">=</span> <span class="n">apply_transform_float</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">Wr</span><span class="p">,</span><span class="n">tform</span><span class="p">,</span><span class="n">padding_mode</span><span class="o">=</span><span class="s1">&#39;zeros&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># make sure anything out of bounds is 0</span>
        <span class="c1">#Wr = Wr_</span>
        
        
        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">Jr</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">fig2</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fig2</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Recon it </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># update atlas</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">compute_atlas_from_slices</span><span class="p">(</span><span class="n">Jr</span><span class="p">,</span><span class="n">Wr</span><span class="p">,</span><span class="n">ooop</span><span class="p">,</span><span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">)</span>
        <span class="c1"># initialize for next time</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;A2d&#39;</span><span class="p">]</span>
        <span class="c1"># draw the result</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span><span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Atlas it </span><span class="si">{</span><span class="n">it</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">fig2</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>

        <span class="c1">#fig.savefig(join(outdir,f&#39;atlas_it_{it:06d}.jpg&#39;))</span>
        <span class="c1">#fig2.savefig(join(outdir,f&#39;recon_it_{it:06d}.jpg&#39;))</span>

    
    <span class="n">out</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">out</span><span class="p">[</span><span class="s1">&#39;Jr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Jr</span>
    
    <span class="k">return</span> <span class="n">out</span></div>
    
        
<span class="c1"># now we&#39;ll start building an interface</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is &#39;register&#39; and &#39;config&#39; argument is None.</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is &#39;register&#39; and atlas name is not specified.</span>
<span class="sd">    Exception</span>
<span class="sd">        If atlas image is not 3D.</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is &#39;register&#39; and target name is not specified.</span>
<span class="sd">    Exception</span>
<span class="sd">        If target image is not a directory (series of slices), and it is not 3D.</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is &#39;transform&#39; and the transform does not include direction (&#39;f&#39; or &#39;b&#39;).</span>
<span class="sd">    Exception</span>
<span class="sd">        If transform direction is not f or b.</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is &#39;transform&#39; and neither atlas name nor label name is specified.</span>
<span class="sd">    Exception</span>
<span class="sd">        If mode is &#39;transform&#39; and target name is not specified.</span>
<span class="sd">    </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set up command line args</span>
    <span class="c1"># we will either calculate mappings or apply mappings</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s1">&#39;Calculate or apply mappings, or run a specified pipeline.&#39;</span><span class="p">,</span> <span class="n">epilog</span><span class="o">=</span><span class="s1">&#39;Enjoy&#39;</span><span class="p">)</span>
    
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-m&#39;</span><span class="p">,</span><span class="s1">&#39;--mode&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify mode as one of register, transform, or a named pipeline&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;register&#39;</span><span class="p">,</span><span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;register&#39;</span><span class="p">,</span><span class="s1">&#39;transform&#39;</span><span class="p">])</span> 
    <span class="c1"># add other choices</span>
    <span class="c1"># maybe I don&#39;t need a mode</span>
    <span class="c1"># if I supply a -x it will apply transforms</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-a&#39;</span><span class="p">,</span><span class="s1">&#39;--atlas&#39;</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the image to be transformed (atlas)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span><span class="s1">&#39;--label&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the label image in atlas space for QC and outputs&#39;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-t&#39;</span><span class="p">,</span><span class="s1">&#39;--target&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the image to be transformed to (target)&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-w&#39;</span><span class="p">,</span><span class="s1">&#39;--weights&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of the target image weights (defaults to ones)&#39;</span><span class="p">)</span>
    
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-c&#39;</span><span class="p">,</span><span class="s1">&#39;--config&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the filename of json config file&#39;</span><span class="p">)</span> <span class="c1"># only required for reg</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-x&#39;</span><span class="p">,</span><span class="s1">&#39;--xform&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify a list of transform files to apply, or a previous output directory&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-d&#39;</span><span class="p">,</span><span class="s1">&#39;--direction&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify the direction of transforms to apply, either f for forward or b for backward&#39;</span><span class="p">,</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;append&#39;</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-o&#39;</span><span class="p">,</span><span class="s1">&#39;--output&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;A directory for outputs&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--output_image_format&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;File format for outputs (vtk legacy and nibabel supported)&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;.vtk&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--num_threads&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optionally specify number of threads in torch&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--atlas_voxel_scale&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optionally specify a scale factor for atlas voxel size (e.g. 1000 to convert mm to microns)&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--target_voxel_scale&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Optionally specify a scale factor for target voxel size (e.g. 1000 to convert mm to microns)&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    
    <span class="c1"># TODO don&#39;t print namespace because it will contain full paths</span>
    <span class="c1">#print(args)</span>
    
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">num_threads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Setting numer of torch threads to </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">num_threads</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">num_threads</span><span class="p">)</span>
    

    
    
    <span class="c1"># if mode is register</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;register&#39;</span><span class="p">:</span>   
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting register pipeline&#39;</span><span class="p">)</span>    
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Config file option must be set to run registration&#39;</span><span class="p">)</span>
        
        <span class="c1"># don&#39;t print because it may contain full paths, don&#39;t want for web</span>
        <span class="c1">#print(f&#39;Making output directory {args.output}&#39;)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="c1">#print(&#39;Finished making output directory&#39;)</span>
    
    
        <span class="c1"># load config</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading config&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">config</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">config</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># I&#39;m getting this for initial downsampling for preprocessing</span>
        <span class="n">downJs</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">]</span>
        <span class="n">downIs</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">config</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">config</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished loading config&#39;</span><span class="p">)</span>
        
        <span class="c1"># load atlas</span>
        <span class="c1">#atlas_name = &#39;/home/dtward/data/csh_data/marmoset/Woodward_2018/bma-1-mri-reorient.vtk&#39;</span>
        <span class="c1">#label_name = &#39;/home/dtward/data/csh_data/marmoset/Woodward_2018/bma-1-region_seg-reorient.vtk&#39;</span>
        <span class="c1">#target_name = &#39;/home/dtward/data/csh_data/marmoset/m1229/M1229MRI/MRI/exvivo/HR_T2/HR_T2_CM1229F-reorient.vtk&#39;</span>

        <span class="c1"># TODO check works with nifti</span>
        <span class="n">atlas_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span>
        <span class="k">if</span> <span class="n">atlas_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify an atlas name to run the registration pipeline&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading atlas </span><span class="si">{</span><span class="n">atlas_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>
        <span class="c1">#if parts[-1] != &#39;.vtk&#39;:</span>
        <span class="c1">#    raise Exception(f&#39;Only vtk format atlas supported, but this file is {parts[-1]}&#39;)</span>
        <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas_voxel_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xI</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">args</span><span class="o">.</span><span class="n">atlas_voxel_scale</span><span class="p">]</span>
        
        
        <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="c1"># pad the first axis if necessary</span>
        <span class="k">if</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> 
            <span class="n">I</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">I</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;3D data required but atlas image has dimension </span><span class="si">{</span><span class="n">I</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>            
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="s1">&#39;inputs/&#39;</span><span class="p">)</span>
        <span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial downsampling so not too much gpu memory&#39;</span><span class="p">)</span>
        <span class="c1"># initial downsampling so there isn&#39;t so much on the gpu</span>
        <span class="n">mindownI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">downIs</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xI</span><span class="p">,</span><span class="n">I</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">mindownI</span><span class="p">)</span>
        <span class="n">downIs</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">/</span><span class="n">mindownI</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downIs</span><span class="p">]</span>
        <span class="n">dI</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xI</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">dI</span><span class="p">)</span>
        <span class="n">nI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># update our config variable</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downI&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downIs</span>
        
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="n">xI</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Atlas image&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="s1">&#39;atlas.png&#39;</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished loading atlas&#39;</span><span class="p">)</span>
        
        <span class="c1"># load target and possibly weights</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="n">target_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify a target name to run the registration pipeline&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading target </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading slices from directory&#39;</span><span class="p">)</span>
            <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">W0</span> <span class="o">=</span> <span class="n">load_slices</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>            
            
        <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.vtk&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading volume from vtk&#39;</span><span class="p">)</span>
            <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_vtk_data</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span> <span class="c1"># there&#39;s a problem here with marmoset, too many values t ounpack</span>
            <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">J</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">J</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;3D data required but target image has dimension </span><span class="si">{</span><span class="n">J</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loading weights from vtk&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">W0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">J</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">target_voxel_scale</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xJ</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">args</span><span class="o">.</span><span class="n">target_voxel_scale</span><span class="p">]</span>
                
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Initial downsampling so not too much gpu memory&#39;</span><span class="p">)</span>
        <span class="c1"># initial downsampling so there isn&#39;t so much on the gpu</span>
        <span class="n">mindownJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">downJs</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xJ</span><span class="p">,</span><span class="n">J</span> <span class="o">=</span> <span class="n">downsample_image_domain</span><span class="p">(</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">mindownJ</span><span class="p">)</span>
        <span class="n">W0</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">W0</span><span class="p">,</span><span class="n">mindownJ</span><span class="p">)</span>
        <span class="n">downJs</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">list</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">/</span><span class="n">mindownJ</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downJs</span><span class="p">]</span>        
        <span class="c1"># update our config variable</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;downJ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downJs</span>
        
        <span class="c1"># draw it</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Target image&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="s1">&#39;target.png&#39;</span><span class="p">))</span>        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished loading target&#39;</span><span class="p">)</span>
        
        <span class="c1"># get one more qc file applying the initial affine</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">config</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="c1"># this affine matrix should be 4x4, but it may be 1x4x4</span>
        <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="n">XJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xJ</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">Xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span><span class="nd">@XJ</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">])[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">Ai</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xs</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">draw</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">xJ</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Initial transformed atlas&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span><span class="s1">&#39;atlas_to_target_initial_affine.png&#39;</span><span class="p">))</span>        

        <span class="c1"># default pipeline</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting registration pipeline&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">emlddmm_multiscale</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I</span><span class="p">)),</span><span class="n">xI</span><span class="o">=</span><span class="p">[</span><span class="n">xI</span><span class="p">],</span><span class="n">J</span><span class="o">=</span><span class="n">J</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="p">)),</span><span class="n">xJ</span><span class="o">=</span><span class="p">[</span><span class="n">xJ</span><span class="p">],</span><span class="n">W0</span><span class="o">=</span><span class="n">W0</span><span class="p">,</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;problem with registration&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;done.txt&#39;</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">pass</span>
            
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished registration pipeline&#39;</span><span class="p">)</span>
        

        <span class="c1"># write outputs      </span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">write_outputs_for_pair</span><span class="p">(</span>
                <span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">output</span><span class="p">,</span>
                <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">WJ</span><span class="o">=</span><span class="n">W0</span><span class="p">,</span>    
            <span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Problem with writing outputs&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;done.txt&#39;</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="k">pass</span>            
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Finished writing outputs&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;done.txt&#39;</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">pass</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # this commented out section was old, we need to make sure to merge properly with Bryson</span>
<span class="sd">        # write transforms</span>
<span class="sd">        print(&#39;Starting to write transforms&#39;)</span>
<span class="sd">        write_transform_outputs(args.output,output)</span>
<span class="sd">        print(&#39;Finished writing transforms&#39;)</span>
<span class="sd">        </span>
<span class="sd">        # write qc outputs</span>
<span class="sd">        # this requires a segmentation image</span>
<span class="sd">        if args.label is not None:</span>
<span class="sd">            print(&#39;Starting to read label image for qc&#39;)</span>
<span class="sd">            xS,S,title,names = read_data(args.label)            </span>
<span class="sd">            S = S.astype(np.int32) # with int32 should be supported by torch</span>
<span class="sd">            print(&#39;Finished reading label image&#39;)</span>
<span class="sd">            print(&#39;Starting to write qc outputs&#39;)</span>
<span class="sd">            write_qc_outputs(args.output,output,xI,I,xJ,J,xS=xI,S=S) # TODO: qrite_qc_outputs input format has changed</span>
<span class="sd">            print(&#39;Finished writing qc outputs&#39;)</span>
<span class="sd">            </span>
<span class="sd">            </span>
<span class="sd">        # transform imaging data</span>
<span class="sd">        # transform target back to atlas</span>
<span class="sd">        Xin = torch.stack(torch.meshgrid([torch.as_tensor(x) for x in xI],indexing=&#39;ij&#39;))</span>
<span class="sd">        Xout = compose_sequence(args.output,Xin)</span>
<span class="sd">        Jt = apply_transform_float(xJ,J,Xout)</span>
<span class="sd">        </span>
<span class="sd">        # transform atlas to target</span>
<span class="sd">        Xin = torch.stack(torch.meshgrid([torch.as_tensor(x) for x in xJ],indexing=&#39;ij&#39;))</span>
<span class="sd">        Xout = compose_sequence(args.output,Xin,direction=&#39;b&#39;)</span>
<span class="sd">        It = apply_transform_float(xI,I,Xout)</span>
<span class="sd">        if args.label is not None:</span>
<span class="sd">            St = apply_transform_int(xS,S,Xout)</span>
<span class="sd">        # write</span>
<span class="sd">        ext = args.output_image_format</span>
<span class="sd">        if ext[0] != &#39;.&#39;: ext = &#39;.&#39; + ext</span>
<span class="sd">        &#39;&#39;&#39;</span>
            
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;transform&#39;</span><span class="p">:</span>
        
        <span class="c1"># now to apply transforms, every one needs a f or a b</span>
        <span class="c1"># some preprocessing</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">direction</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">)</span>        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;You must input a direction for each transform, but you input </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">)</span><span class="si">}</span><span class="s1"> transforms and </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span><span class="si">}</span><span class="s1"> directions&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">tform</span><span class="p">,</span><span class="n">direction</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">,</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">direction</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span><span class="s1">&#39;b&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Transform directions must be f or b, but you input </span><span class="si">{</span><span class="n">direction</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            
            
            
        <span class="c1"># load atlas</span>
        <span class="c1"># load target (to get space info)</span>
        <span class="c1"># compose sequence of transforms</span>
        <span class="c1"># transform the data</span>
        <span class="c1"># write it out</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atlas_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span>
        <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atlas_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">label</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify an atlas name or label name to run the transformation pipeline&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading atlas </span><span class="si">{</span><span class="n">atlas_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>        
        <span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)</span>        
        
        <span class="c1"># load target and possibly weights</span>
        <span class="n">target_name</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">target</span>
        <span class="k">if</span> <span class="n">target_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;You must specify a target name to run the transformation pipeline (TODO, support specifying a domain rather than an image)&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading target </span><span class="si">{</span><span class="n">target_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        <span class="n">xJ</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">title</span><span class="p">,</span><span class="n">names</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">(</span><span class="n">target_name</span><span class="p">)</span>
        
        <span class="c1"># to transform an image we start with Xin, and compute Xout</span>
        <span class="c1"># Xin will be the grid of points in target</span>
        <span class="n">Xin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">torch</span><span class="o">.</span><span class="n">as_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xJ</span><span class="p">],</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>
        <span class="n">Xout</span> <span class="o">=</span> <span class="n">compose_sequence</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">d</span>  <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">xform</span><span class="p">,</span><span class="n">args</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="p">],</span> <span class="n">Xin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">atlas</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">It</span> <span class="o">=</span> <span class="n">apply_transform_float</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">It</span> <span class="o">=</span> <span class="n">apply_transform_int</span><span class="p">(</span><span class="n">xI</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">Xout</span><span class="p">)</span>
        
        <span class="c1"># write out the outputs        </span>
        <span class="n">ext</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">output_image_format</span>
        <span class="k">if</span> <span class="n">ext</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">ext</span>                    
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
        <span class="c1"># name should be atlas name to target name, but without the path</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">atlas_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_to_&#39;</span> <span class="o">+</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">target_name</span><span class="p">)[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">write_data</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">name</span><span class="o">+</span><span class="n">ext</span><span class="p">),</span><span class="n">xJ</span><span class="p">,</span><span class="n">It</span><span class="p">,</span><span class="s1">&#39;transformed data&#39;</span><span class="p">)</span>
        <span class="c1"># write a text file that summarizes this</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">,</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;.txt&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s1">&#39;wt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
         
    <span class="c1"># also </span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Daniel Tward, Bryson Gray, Partha Mitra.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>